<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="wind2412的部落格✨～">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wind2412的部落格✨～">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wind2412的部落格✨～">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>wind2412的部落格✨～</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97977742-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?733fc494d1c5b28a5bef03609254381d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wind2412的部落格✨～</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/26/VSCode-cpp-检索-include-路径的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wind2412">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blue_sky.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wind2412的部落格✨～">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/26/VSCode-cpp-检索-include-路径的问题/" itemprop="url">
                  VSCode cpp 检索 include 路径的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T11:28:48+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>碰到了一个 VSCode include 路径的问题。我的项目路径在 {workspaceRoot}/include 下，一开始想要以 <code>-I./include</code> 的方式来编译的。不过在 VSCode 中遇到了些麻烦。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>使用的是 Microsoft C/C++ Extension。这个插件非常棒，但是在 mac 上因为 bug 的原因之前经常烫烫烫。好在已经 fix 了。在项目路径下的 .vscode 的文件夹下一般而言有四大金刚：<code>c_cpp_properties.json</code>，<code>launch.json</code>,<code>settings.json</code> 以及 <code>tasks.json</code>。其中 $1 用于配置 path……我都没怎么碰过这东西……还以为没啥用呢（。一般配置的都是 $2 和 $4。$3 是自动生成的用户配置，不用管就好。$2 <code>launch.json</code> 用于调试，而 <code>tasks.json</code> 用于 build &amp;&amp; run。</p>
<p>查了半天，在 VSCode 的官方博客上找到了：应该在 $1 <code>c_cpp_properties.json</code> 中配置路径。所以变成了现在这样：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">"configurations": [</div><div class="line">        &#123;</div><div class="line">            "name": "Mac",</div><div class="line">            "includePath": [</div><div class="line">                "/usr/include",</div><div class="line">                "/usr/local/include",</div><div class="line">                "/usr/include/c++/4.2.1",</div><div class="line">                "/usr/include/c++/4.2.1/tr1",</div><div class="line">                "$&#123;workspaceRoot&#125;/include"</div><div class="line">            ],</div><div class="line">            "browse": &#123;</div><div class="line">                "limitSymbolsToIncludedHeaders": true,</div><div class="line">                "databaseFilename": "",</div><div class="line">                "path": [</div><div class="line">                    "/usr/include",</div><div class="line">                    "/usr/local/include",</div><div class="line">                    "$&#123;workspaceRoot&#125;/include"</div><div class="line">                ]</div><div class="line">            &#125;,</div><div class="line">            ......</div></pre></td></tr></table></figure></p>
<p>emmmm。虽然我不知道 browse 那是什么东西。不过还是加上吧。<br>然而鬼畜的来了：特么竟然还是报错！！按官博说的，应该已经好了！！<br>痛苦地找了一个晚上。。。。。。<br>现在已经是第二天中午了QAQ。<br>正当我打开 issue，想要像 vscode-cpptools 官方 repository 上报 issue 的时候，看到了官方的提示：<strong>上报 issue 之前，请关闭其他插件。看看是否是其他插件的影响。</strong></p>
<p>上报 issue 之前，请关闭其他插件。看看是否是其他插件的影响。<br>上报 issue 之前，请关闭其他插件。看看是否是其他插件的影响。<br>上报 issue 之前，请关闭其他插件。看看是否是其他插件的影响。</p>
<p>卧槽，其实这个时候我都没怎么在意……因为另一个插件是我非常喜欢的 clang 的插件啊！虽然不是 clang 官方的（，叫 C/C++ Clang Command Adapter。是五星的插件啊！而且是个霓虹开发者开发的！OWO<br>然后我关了它。<br>竟然好了！！可以索引了！！<br>于是我看了下介绍……<br>这插件里边写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Variables</div><div class="line"></div><div class="line">Configurations support some variables which are available in tasks.json. They can be used inside of strings (e.g. &quot;-I$&#123;workspaceRoot&#125;/include&quot;)</div><div class="line"></div><div class="line">  $&#123;workspaceRoot&#125;</div><div class="line">  $&#123;cwd&#125;</div><div class="line">  $&#123;env.ENVIRONMENT_VARIABLE&#125;</div></pre></td></tr></table></figure></p>
<p>于是我跑到 <code>task.json</code>，在 args 一栏中加了这个：<br><code>&quot;args&quot;: [&quot;-I${workspaceRoot}/include&quot;],</code><br>然后就好了……QAQ<br>然而这就比较诡异了……在点击头文件跳转的时候，关了微软官方的插件就不能跳转；关了 clang 插件，还是能够跳转。说明 clang 插件不对跳转有任何的作用；但是，只要没有配置 args，头文件就会出现红线报错，这时微软的插件检测到错误，也不会帮你跳转……卧槽。这是插件冲突的玄学吗……</p>
<p>emmmm。下次一定要注意，别因为印象好就单独开小灶……因为真正的错误往往藏在你放心的位置，然后耽误你大量的时间……QAQ。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/23/解析-dylib-文件并且找到-java-native-方法的源代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wind2412">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blue_sky.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wind2412的部落格✨～">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/23/解析-dylib-文件并且找到-java-native-方法的源代码/" itemprop="url">
                  解析 dylib 文件并且找到 java native 方法的源代码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-23T01:13:49+08:00">
                2017-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/wangweixaut061/article/details/7164809" target="_blank" rel="external">参见博客</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nm libjava.dylib</div><div class="line">gobjdump -tT libjava.dylib  // 使用 brew install binutils 安装</div></pre></td></tr></table></figure></p>
<p>Native 方法在 Oracle Java 是不让看的。我们只能从 Openjdk 中看。我在编译好的 openjdk 源码的 build.log 中找到了一大堆 native 方法的编译 log，但是却没有发现它们到底最后被编译到哪了。而且挨个翻 Makefile 也是不太可能的（看不懂哈哈）。于是只能暴力一些了。找到 Openjdk 目录下的各种 libs，首先我的 jdk 在前一个博客也说过是 openjdk8。在 <code>&lt;yourjdk&gt;/build/macosx-x86_64-normal-server-****/jdk/lib</code> 下，有一大堆的 libs。我估计就是他们（逃）。但是怎么确认呢？请参加上方的 blog。执行那两个命令之中的任意一个。然后你就会得到一大堆的输出。然后随便找一个函数，直接在源码目录 <code>yourjdk/jdk/src/share/native</code> 目录下使用 <code>grep -rn &lt;method_name&gt; .</code> 就好了！然后发现确实能查到的！虽然不能一一对应就是了。不过这样也是大有进展，这样就可以直接调用人家写好的 Native 方法了～</p>
<p>外赠一个 shell 脚本来检查到底某个 native 方法被放到哪个 dylib 中去了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cd &lt;yourjdk&gt;/build/macosx-x86_64-normal-server-****/jdk/lib # 此句是伪码</div><div class="line"></div><div class="line">for file in ./*</div><div class="line">do</div><div class="line">if [[ "$file" =~ "dylib$" ]]    # 以 dylib 结尾的文件</div><div class="line">then</div><div class="line">nm $file | grep registerNative | xargs -0 echo $file &#123;&#125; # registerNative 可以换成你要查找的方法名～</div><div class="line">fi</div><div class="line">done</div></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 输出：</div><div class="line">./libawt.dylib &#123;&#125; 00000000000403e0 T _Java_sun_java2d_loops_GraphicsPrimitiveMgr_registerNativeLoops</div><div class="line"></div><div class="line">./libhprof.dylib &#123;&#125; 000000000001ab63 T _registerNatives   # 很清晰地知道，我们要找的 registerNatives 函数在 libhprof.dylib 中～</div><div class="line"></div><div class="line">./libjava.dylib &#123;&#125; 00000000000028d0 T _Java_java_lang_ClassLoader_registerNatives</div><div class="line">0000000000002460 T _Java_java_lang_Class_registerNatives</div><div class="line">0000000000003f10 T _Java_java_lang_Compiler_registerNatives</div><div class="line">0000000000006ea0 T _Java_java_lang_Object_registerNatives</div><div class="line">00000000000096d0 T _Java_java_lang_System_registerNatives</div><div class="line">000000000000f110 T _Java_java_lang_Thread_registerNatives</div></pre></td></tr></table></figure>
<hr>
<p>随后我还是查看了 Makefile……<br>比如 libjava 的 output 指定的 Makefile 脚本在：</p>
<p><yourjdk>/jdk/make/lib/CoreLibraries.gmk 下。(gmk 即 Gnu Makefile)<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 116 - 129 行</div><div class="line">LIBJAVA_SRC_DIRS := <span class="variable">$(JDK_TOPDIR)</span>/src/<span class="variable">$(OPENJDK_TARGET_OS_API_DIR)</span>/native/java/lang \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/share/native/java/lang \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/share/native/java/lang/reflect \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/share/native/java/io \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/<span class="variable">$(OPENJDK_TARGET_OS_API_DIR)</span>/native/java/io \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/share/native/java/nio \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/share/native/java/security \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/share/native/common \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/share/native/sun/misc \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/share/native/sun/reflect \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/share/native/java/util \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/share/native/java/util/concurrent/atomic \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/<span class="variable">$(OPENJDK_TARGET_OS_API_DIR)</span>/native/common \</div><div class="line">    <span class="variable">$(JDK_TOPDIR)</span>/src/<span class="variable">$(OPENJDK_TARGET_OS_API_DIR)</span>/native/java/util</div><div class="line"><span class="comment"># 这一部分指出了 libjava 的 src。所有的这些 Native 文件最后都被打包成为 libjava.dylib 的一部分。</span></div><div class="line"></div><div class="line">// 220 - 224 行</div><div class="line"><span class="variable">$(BUILD_LIBJAVA)</span>: <span class="variable">$(LIBJLI_BINARY)</span>  <span class="comment"># 这个命令开始 build libjli.dylib，在 &lt;yourjdk&gt;/build/macosx-x86_64-normal-server-****/jdk/lib/ 下</span></div><div class="line"></div><div class="line"><span class="variable">$(BUILD_LIBJAVA)</span>: <span class="variable">$(BUILD_LIBVERIFY)</span>  <span class="comment"># 这个命令开始 build libverify.dylib，位置同上</span></div><div class="line"></div><div class="line"><span class="variable">$(BUILD_LIBJAVA)</span>: <span class="variable">$(BUILD_LIBFDLIBM)</span>    <span class="comment"># 这个命令开始 build libfdlibm.a，在 &lt;yourjdk&gt;/build/macosx-x86_64-normal-server-****/jdk/obj/ 下。</span></div><div class="line"></div><div class="line"><span class="comment"># libjava.dylib 依赖这三个 lib。</span></div></pre></td></tr></table></figure></yourjdk></p>
<p>嗯嗯。还想要继续找的话，请各种使用 grep 命令会方便很多～</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/20/Mac-环境使用-clang-编译-OpenJDK8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wind2412">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blue_sky.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wind2412的部落格✨～">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/20/Mac-环境使用-clang-编译-OpenJDK8/" itemprop="url">
                  Mac 环境使用 clang 编译 OpenJDK8
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-20T10:19:22+08:00">
                2017-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h1><p>搞了 3 个晚上，终于搞定了。在 mac 上各种版本不适配，也是很有意思的～需要折腾，需要折腾～</p>
<hr>
<h1 id="参看博客："><a href="#参看博客：" class="headerlink" title="参看博客："></a>参看博客：</h1><p><a href="https://github.com/ydcun/Java/blob/master/java/src/main/java/com/ydcun/openjdk/jdk8/MAC编译OpenJDK8.md" target="_blank" rel="external">主要参照</a><br><a href="http://www.guinguo.top/2016/05/03/JVM学习之OpenJDK源码编译/" target="_blank" rel="external">主要参照的补充: 编译 debug 版 openjdk</a><br><a href="http://hllvm.group.iteye.com/group/topic/39814#post-260210" target="_blank" rel="external">R大的答案</a><br><a href="http://blog.csdn.net/lizhengjava/article/details/60138890" target="_blank" rel="external">很好的博客</a><br><a href="https://stackoverflow.com/a/21443288/7093297" target="_blank" rel="external">重点！对 mac 下 libiconv 的操作</a><br><a href="https://yddmax.github.io/2017/06/12/openjdk8之编译和debug/" target="_blank" rel="external">调试你的 openjdk</a></p>
<hr>
<h1 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h1><p>按照<code>主要参照</code>的 github 上边的过程一步步来，注意要使用 clang 而不是 gcc。其实在 mac 就应该使用 clang，因为 gcc 不知道会引发什么潜在的隐患那…… 而且 clang 生成的调试信息貌似要比 gcc 好些吧。但是要注意：如果你想要调试的话，就要看看<code>主要参照的补充</code>那个博客了。因为 <code>sh configure</code> 后边需要有参数。我将会列在下边。</p>
<hr>
<h1 id="各种版本："><a href="#各种版本：" class="headerlink" title="各种版本："></a>各种版本：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; clang -v</div><div class="line">Apple LLVM version 8.1.0 (clang-802.0.42)</div><div class="line">Target: x86_64-apple-darwin16.7.0</div><div class="line">Thread model: posix</div><div class="line">InstalledDir: /usr/bin</div><div class="line"></div><div class="line">&gt; clang++ -v</div><div class="line">Apple LLVM version 8.1.0 (clang-802.0.42)</div><div class="line">Target: x86_64-apple-darwin16.7.0</div><div class="line">Thread model: posix</div><div class="line">InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</div><div class="line"></div><div class="line">&gt; java -version</div><div class="line">java version &quot;1.8.0_111&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_111-b14)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)</div></pre></td></tr></table></figure>
<ol>
<li>以上即是各种 tools 的信息。注意，最好开着 VPN 进行 hg 的 pull 操作。因为这样下载速度会飙得很快～ 而且用 hg 貌似易于更新的话说。</li>
<li>其中，XQuartz 请下载最新的官网版本。不要用<code>主要参照</code>给出的链接，请自行使用 <code>brew cask install XQuartz</code> 来进行 brew 安装。因为链接给出的 XQuartz 版本太老了，是 SnowLeopard 版本的 mac 才适配的。</li>
<li><code>xcode-select -install</code> 在我这里已经没用了。不过貌似工具链完整，也不需要安装了。</li>
<li>编译开始之前，请一定要把 <code>/usr/bin/gcc</code> 和 <code>/usr/bin/g++</code> 改成 <code>clang</code> 和 <code>clang++</code>！因为 <code>./configure</code> 的时候会搜索这两个路径确认编译器 <code>gcc</code> 以及 <code>g++</code>。当然，如果你原先没有做过交叉编译啥的修改过 <code>/usr/bin/gcc</code> 和 <code>/usr/bin/g++</code> 的话，那么请忽略我这些话。</li>
<li>我的 shell 脚本，参照了一堆人的脚本，列举如下。我自己略加修改：<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 设定语言选项，必须设置</div><div class="line">export LANG=C</div><div class="line"><span class="meta">#</span> Mac平台，C编译器不再是GCC，是clang</div><div class="line">export CC=gcc</div><div class="line"><span class="meta">#</span> 跳过clang的一些严格的语法检查，不然会将N多的警告作为Error</div><div class="line">export COMPILER_WARNINGS_FATAL=false</div><div class="line"><span class="meta">#</span> 链接时使用的参数</div><div class="line">export LFLAGS='-Xlinker -lstdc++'</div><div class="line"><span class="meta">#</span> 是否使用clang</div><div class="line">export USE_CLANG=true</div><div class="line"><span class="meta">#</span> 使用64位数据模型</div><div class="line">export LP64=1</div><div class="line"><span class="meta">#</span> 告诉编译平台是64位，不然会按32位来编译</div><div class="line">export ARCH_DATA_MODEL=64</div><div class="line"><span class="meta">#</span> 允许自动下载依赖</div><div class="line">export ALLOW_DOWNLOADS=true</div><div class="line"><span class="meta">#</span> 并行编译的线程数，编译时间长，为了不影响其他工作，我选择为2</div><div class="line">export HOTSPOT_BUILD_JOBS=6</div><div class="line">export ALT_PARALLEL_COMPILE_JOBS=6</div><div class="line"><span class="meta">#</span> 是否跳过与先前版本的比较</div><div class="line">export SKIP_COMPARE_IMAGES=true</div><div class="line"><span class="meta">#</span> 是否使用预编译头文件，加快编译速度</div><div class="line">export USE_PRECOMPILED_HEADER=true</div><div class="line"><span class="meta">#</span> 是否使用增量编译</div><div class="line">export INCREMENTAL_BUILD=true</div><div class="line"><span class="meta">#</span> 编译内容</div><div class="line">export BUILD_LANGTOOLS=true</div><div class="line">export BUILD_JAXP=false</div><div class="line">export BUILD_JAXWS=false</div><div class="line">export BUILD_CORBA=false</div><div class="line">export BUILD_HOTSPOT=true</div><div class="line">export BUILD_JDK=true</div><div class="line"><span class="meta">#</span> 编译版本</div><div class="line">export SKIP_DEBUG_BUILD=true</div><div class="line">export SKIP_FASTDEBUG_BUILD=false</div><div class="line">export DEBUG_NAME=debug</div><div class="line"><span class="meta">#</span> 避开javaws和浏览器Java插件之类的部分的build</div><div class="line">export BUILD_DEPLOY=false</div><div class="line">export BUILD_INSTALL=false</div><div class="line"><span class="meta">#</span> 加上产生调试信息时需要的 objcopy</div><div class="line"><span class="meta">#</span> export OBJCOPY=gobjcopy</div></pre></td></tr></table></figure>
</li>
</ol>
<p>把它命名为 <code>jvm.sh</code> 的话，我们只需要执行 <code>source ./jvm.sh</code> 即可把临时环境变量设置好。</p>
<ol>
<li><code>主要参照</code> 的所有问题都遇到了。不得不说这是十分良心的经验～</li>
<li>不过，如果你要进行调试的话，需要把一开始的 <code>sh configure</code> 变成：<code>sh configure --with-target-bits=64 --with-debug-level=slowdebug --enable-debug-symbols ZIP_DEBUGINFO_FILES=0</code>。这样就会产生足够多数量的调试信息，方便调试～</li>
<li>如果你遵循了第 6 条，那么最后会提示你缺少 <code>objcopy</code>。那么请使用 <code>brew install binutils</code> 来安装 GNU 的组件，并且把 <code>jvm.sh</code> 的最后一行取消注释才行！</li>
<li>然后愉快地 make all 即可！</li>
</ol>
<hr>
<h1 id="坑们"><a href="#坑们" class="headerlink" title="坑们"></a>坑们</h1><p>在我这里只出现了一个大坑，然而弄到了半夜QAQ。就是当编译 <code>make all</code> 的时候，到了编译 jdk 的时候，编译了一半出现了诡异的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Undefined symbols for architecture x86_64:</div><div class="line">  &quot;_libiconv&quot;, referenced from:</div><div class="line">  ......</div><div class="line">  &quot;_libiconv_close&quot;, referenced from:</div><div class="line">  ......</div><div class="line">  &quot;_libiconv_open&quot;, referenced from:</div><div class="line">  ......</div></pre></td></tr></table></figure></p>
<p>这种狗血的错误。然后一看名就知道了……分明应该是 libiconv 的问题……然而特么一查，电脑中有各种 <code>libiconv.dylib</code> 包，还有各种花式的 <code>libiconv.2.dylib</code> 以及 <code>libiconv.2.4.0.dylib</code>…… 而且散布在不同目录下……我都不知道链接哪个才是正确的……于是不得不上网查，谷歌谷不出来还是百度百出来的（逃，(因为可能是谷歌不支持特殊字符的原因吧……)，然后就查到了有一个回答支持，链接也贴出来了：<a href="https://stackoverflow.com/a/21443288/7093297" target="_blank" rel="external">重点！对 mac 下 libiconv 的操作</a>。这个回答只要做第一步就好。即，把 <code>/usr/lib/libiconv.dylib</code> 变成 <code>/usr/lib/libiconv1.dylib</code> 即可，让链接库找不到就 ok。结果链接的是 <code>/usr/bin</code> 目录下的这个文件……其实 <code>/usr/local/bin/</code> 里边还有同名的一套 libiconv 呢……<br>不过改完之后就能碰到 <code>主要参照</code> 的第三个错误了，照改不误就可以。对于这份 github 的经验实在是感激不尽！帮了大忙。</p>
<hr>
<h1 id="世界的终结"><a href="#世界的终结" class="headerlink" title="世界的终结"></a>世界的终结</h1><p>打开你自己的 <code>build/macosx-x86_64-normal-server-slowdebug/jdk/bin</code> 目录，然后 <code>./java</code>，出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">用法: java [-options] class [args...]</div><div class="line">           (执行类)</div><div class="line">   或  java [-options] -jar jarfile [args...]</div><div class="line">           (执行 jar 文件)</div><div class="line">其中选项包括:</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>就算大功告成！<br>但是，如果没有出现这，而是出现什么类似 <code>某个文件800行有问题，提示你编译不完全</code> 的错误提示的话，那你怕是要返工了。当时在 Docker 下 的 ubuntu 虚拟机编译的（其实我就把它当轻量的虚拟机来用HAHA，当时就出现了这个错误。而且错误信息中显示时间戳不对，肯定是编译的过程中出了些岔子吧。</p>
<p>如果你产生了调试信息，那么可以参见 <code>调试你的 openjdk</code> 的最后方，有调试的方法，很简单～</p>
<p>Enjoy it！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/15/使用-mac-同步-Markdown-的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wind2412">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blue_sky.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wind2412的部落格✨～">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/15/使用-mac-同步-Markdown-的方法/" itemprop="url">
                  使用 mac 同步 Markdown 的方法......
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-15T23:47:19+08:00">
                2017-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>用 Quiver 写完之后，导出为 Markdown 然后放在一个文件夹下，然后用 MWeb 进行导入，但是导入后的图片格式会有 Quiver 自动生成的<code>xxx = 380x300</code>这种图片格式，需要用正则替换：<code>\s=[0-9]+x[0-9]+</code> 替换成全空字符即可，这样图片格式就只剩下原先的<code>xxx</code>了，而后边由 Quiver 自动生成的图片尺寸格式就会被正则删除了。然后，用 MWeb 直接发布到 wordpress 上，由于 MWeb 会直接转成 wordpress 的图片地址，所以直接就可以发布上去；但是，如果仅仅正常发布的话，我们就只能看到最后的结果，但是却并不能得到 Markdown 的格式。所以最后我们需要勾选：<strong>发布为 Markdown 格式</strong> 这个选项！然后发布到 wordpress 上，之后直接复制粘贴所有的，然后本地 hexo new 之后复制粘贴即可……关键问题是我特别喜欢用 Quiver 写，但是 Quiver 还没有一键发布的功能……所以只能采用这样间接迂回的方案了……不过这样也特别快速，不过唯一的缺点就是最后要手动清理发布的 wordpress 版本和本地由 Quiver 导出的 Markdown 了……但是其他的使用体验还是相当棒的！欢迎来尝试～其实如果你用 MWeb 这种就可以的话，那么 MWeb 一键就可以上传～不过我更喜欢 Quiver 的界面～</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/15/Design-Pattern-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wind2412">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blue_sky.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wind2412的部落格✨～">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/15/Design-Pattern-2/" itemprop="url">
                  Design Pattern 2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-15T23:32:10+08:00">
                2017-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前的笔记实在是有些简陋，如今要正式地重来一遍咯！</p>
<ol>
<li>Observer<br><img src="https://wind2412.files.wordpress.com/2017/10/1312de348af17c9be249c3ab6be49d9d5.jpg" alt="IMAGE">￼<br>如 UML 图所见，Subject 和 Object 都是接口，仅仅定义了对于模式实现的方法，而 ConcreteSubject 和 ConcreteObject 才是实现类。</li>
</ol>
<ul>
<li>对象模型：Subject 中含有一个 Object 的 List，代表它要通知的 Objects。而每一个 Object 中含有一个对自己 Subject 的引用。</li>
<li><code>pull模式</code>：Subject 中的 <code>Notify()</code> 方法以及 Object 中的 <code>Update()</code> 方法才是重点。<code>Subject::Notify()</code> 使用轮询的方式来调用它内部每个 Object 的 <code>Object::Update()</code> 方法。而 <code>Object::Update()</code> 方法往往又调用 Subject 的 <code>Subject::getState()</code> 方法来拉取状态。其实这就是 Observer 的 <code>pull方法</code>，即由 Observer 自身去拉取的手段。</li>
<li><code>push模式</code>：当然对应地，还有种实现手段是 <code>push方法</code>。即 Subject 调用 <code>Subject::Notify()</code> 开启 <code>Object::Update()</code> 的时候。传入自身的 State 进去。这样 Object 在实现 <code>Object::Update()</code> 的时候，就不去要从 Subject 中 pull 来，因为 Subject 已经 push 过去了。但是这样实现，弹性比较小，正常的标准还是 <code>pull模式</code>。</li>
</ul>
<ol>
<li>Strategy<br><img src="https://wind2412.files.wordpress.com/2017/10/fce70ae306b54ea1b7b6b5b6fd290b5b5.jpg" alt="IMAGE">￼<br>如 UML 图所见，Strategy 是接口类，仅仅定义了 strategy 接口。而同一层继承体系下，分化出来多个 ConcreteStrategy 类。</li>
</ol>
<ul>
<li>对象模型：Context 的内部内含一个 Strategy 对象的引用。而 Strategy 是一个接口体系，可以在同一层继承下分化出来多个 SubStrategy。</li>
<li>过程：举 awt 的栗子来说：<br><img src="https://wind2412.files.wordpress.com/2017/10/8d1cf8f82e31ee611840d3bddd9057745.jpg" alt="IMAGE">￼<br>“<code>Java
JFrame jframe(…); // JFrame 是 Container 的一个子对象，即 Context
jFrame.setLayout(new FlowLayout()); // 添加一个 Strategy 到 Context 中。
jframe.add(new JButton()); // JFrame::add 方法会在内部调用 FlowLayout 的 Strategy 方法，产生一种布局模式。
“</code></li>
<li>更多的栗子：同样的栗子还有：Sorter 内部存放一个 SorterStrategy 的引用，可以赋值为 SorterStrategy 体系下的 SubStrategy，必须 BinarySortStrategy 对象，BubbleSortStrategy 对象，HeapSortStrategy 对象等等。<br><img src="https://wind2412.files.wordpress.com/2017/10/56f57bc0b7c0fb8ff0175350742298695.jpg" alt="IMAGE">￼</li>
<li>还有游戏一进去就有的选择困难等级：容易、中等、难、困难、修罗模式这种，也是策略模式的体现！</li>
</ul>
<ol>
<li>Factory<br><img src="https://wind2412.files.wordpress.com/2017/10/30edc0e01dc0e46bfd304a7c148629155.jpg" alt="IMAGE">￼<br>如 UML 图所见，Product 是一个抽象产品类，下方有继承的 ConcreteProduct 实体的产品类。Creator 是接口工厂，内含多态的 <code>Creator::FactoryMethod</code> 方法，返回一个集成体系下的顶层抽象产品类 <code>Product</code>。ConcreteCreator 是实体工厂，用于生产 ConcreteProduct。</li>
</ol>
<ul>
<li>对象模型：Creator 工厂内部没有任何成员变量，只有工厂方法。但是 Creator 工厂内部的方法可以全是 static 的。这就是一种变种，叫做<strong>静态工厂</strong>。好处在于，不用创建工厂的实体对象了～</li>
<li>变种1：简单的工厂方法：不需要写抽象的 Creator，因为体系比较简单，直接上来就是一个简单的<strong>实体+静态</strong>工厂。<br><img src="https://wind2412.files.wordpress.com/2017/10/caee8f1c304c496071c1651af4f905425.jpg" alt="IMAGE">￼</li>
<li>变种2：对于生产同一个继承体系的多种产品，可以在工厂中只写一个方法，内部使用 <code>if…elif…else</code> 的手段，最后产生的对象挂接到高层产品接口的句柄上返回。<br><img src="https://wind2412.files.wordpress.com/2017/10/fe8365b2de82f7458eab45e955db7a1b5.jpg" alt="IMAGE">￼<br>如图，此 Concrete Factory 的 <code>produce()</code> 方法签名返回高层的 Product。</li>
<li>变种3：Product <strong>接口</strong>自己就是一个工厂，可以使用多态(子Product 中分别实现)产生继承体系下的多种类型的 ConcreteProduct。当然，这个多态工厂方法必然返回 <code>Product*</code> 的句柄就是，而且可以使用 <code>static</code> 静态方法。<br><img src="https://wind2412.files.wordpress.com/2017/10/883674d07e93c884378e08391d7408225.jpg" alt="IMAGE">￼</li>
<li>变种4：ConcreteProduct 本身是一个工厂，可以产生自己。(我们只有一种产品)<br><img src="https://wind2412.files.wordpress.com/2017/10/d912ac56240eb34fb7fb7738a44d9c225.jpg" alt="IMAGE">￼</li>
<li>用途：Java 框架中的依赖注入(IoC中) 等等。</li>
</ul>
<ol>
<li>Abstract Factory<br><img src="https://wind2412.files.wordpress.com/2017/10/76a70e7dcedf267ef963bb7468975d395.jpg" alt="IMAGE">￼<br>和 Factory 的不同之处仅仅在于，</li>
</ol>
<ul>
<li>Abstract Factory 是把工厂自身当做产品的。即，<strong>生产工厂的工厂</strong>。</li>
<li>Abstract Factory 由于有上边的这种性质，因此它不再局限于只能像 Factory 一样仅仅能够生产一个体系中的 Product。通过生产出不同类别的工厂，它能够自扩展而生产别的体系的 Product。我们从 UML 图即可看出。</li>
<li>缺点：支持新种类的 Product 变得很麻烦了。</li>
</ul>
<ol>
<li>Decorator<br><img src="https://wind2412.files.wordpress.com/2017/10/cf598de9f6bc240de26a397558351b735.jpg" alt="IMAGE">￼<br>如 UML 图可见，最高层是一个抽象类 Component。它下方<strong>一定有一个</strong>直属的子类 ConcreteComponent，要不 Decorator 无法使用了。因为 Decorator 虽然也继承 Component，但是它的内部也有一个 Component 的句柄引用！那个句柄引用的正体显而易见就是那个直属的 ConcreteComponent。因为装饰者模式的策略就是：<strong>在同一继承体系中，使用已经实现好的子类，在新的子类中扩展它的功能，变成新的功能。</strong></li>
</ol>
<ul>
<li>对象模型：ConcreteComponent 成员变量不能有同类的 Component 句柄，但是 Decorator 的内部必须有一个同类的 Component 句柄！因为 Decorator 要对 ConcreteComponent 的功能进行扩展，从而衍生出自己的新功能，而不用完全从头来写。Decorator 的构造函数要传递一个被扩展的同体系的对象，UML 图中即是 ConcreteComponent。</li>
<li>经典用途：Java 的 IO 系统。比如 BufferedInputStream 啥的都是继承自上层的 InputStream，但是自己构造的时候又要接收一个 InputStream 对象。<br><img src="https://wind2412.files.wordpress.com/2017/10/ec3f046a48a6b71d7a10d88e93891da95.jpg" alt="IMAGE">￼</li>
<li>这也就给出了：<strong>为什么不在类上用继承进行扩展呢</strong> 这个问题的真正答案。很简单，<strong>因为装饰者模式比继承要灵活，弹性更大</strong>。像我们的 BufferedInputStream，既可以接收别的 FileInputStream，也可以满足比如来自 Socket 的 socket.getInputStream() 的接收这样的场景。所以，如果上层有其他的 InputStream 体系的实现，BufferedInputStream 这个装饰者可以对他们进行<strong>统一扩展</strong>，而不再仅仅局限于继承的<strong>仅仅扩展一个InputStream</strong>。这样弹性会变得非常巨大～</li>
</ul>
<ol>
<li>Singleton<br><img src="https://wind2412.files.wordpress.com/2017/10/50c2e92f282a4c20e6452fe9f296d7af5.jpg" alt="IMAGE">￼<br>这个实在是基础中的基础，不讲了。但是在多线程之下，Java 中 Singleton 模式也是有很多大坑的，尤其是 LazyEvaluation。<br><a href="http://blog.csdn.net/haoel/article/details/4028232" target="_blank" rel="external">单例模式的博客</a><br><strong>不过要换成 C++，就连 Eager Singleton 也有大坑！！！</strong><br>一开始，我认为只有这样，用 <code>shared_ptr</code> 智能指针才行：<br>“`cpp<br>// 错误的 Singleton 范例！！<br>class Singleton{<br>private:<br>static shared_ptr singleton;<br>Singleton() {}<br>public:<br>static shared_ptr getSingleton() {<br>return singleton;<br>}<br>};</li>
</ol>
<p>shared_ptr Singleton::singleton = shared_ptr(new Singleton); // 用原生指针 new 一个 static 变量，最后会造成内存无法释放而泄漏。<br>“<code>上边的想法确实在我自己看来是还中规中矩的……不过这两天正好读完了 Scott Meyers 的 Effective C++……其中的第四条款指出，static 这种全局变量，虽然会在使用时初始化，但是和 Java 也有本质的不同。Java 的话，在虚拟机 JVM 进行类加载的时候，会有一个“类的初始化”期，这期间会直接初始化所有 static 变量和 static 块。因此，Eager Singleton 在 Java 中可谓是天然适配，上来就默认多线程友好；但是 C++ 不一样……确实在调用之前，static 也会初始化；但是 C++ 标准并没有规定 **多个编译单元中 static 的初始化顺序**！！也就是，在多个模块中，non-local static 变量的初始化顺序是未知的！具体原因请直接看 Meyers 的 Effective C++ Item 04。因此，Meyers 指出，在 C++ 想要 Singleton 安全，必须把 non-local static 变成一个 local static，其实表现形式上，变成了一个**工厂函数**！更改后的程序见下：
“</code>cpp<br>// 正确的 Eager Singleton，而且不再使用恶心的 static new！<br>class Singleton{<br>private:<br>Singleton();<br>Singleton(const Singleton &amp;);<br>Singleton&amp; operator= (const Singleton &amp;);<br>~Singleton();<br>public:<br>static Singleton&amp; getSingleton() {<br>static Singleton singleton;<br>return singleton;<br>}<br>};// 注意一定要注销掉 copy constructor 以及 constructor 还有 assignment operator！！要不，最后会发生可以拷贝的愚蠢现象……比如 Singleton s = getSingleton()，因为调用的是拷贝构造函数……所以必须 private 化。因为 C++ 可以分配在栈上，因此和 Java 全是堆引用不同～<br>“`<br>参考了一个博客：<a href="http://www.zkt.name/dan-li-mo-shi-singleton-ji-c-shi-xian/" target="_blank" rel="external">ZKT的笔记本</a>，在我迷惑的时候它帮助了我。当然，虽然还没有看，但是《Modern C++ Design》中用 TMP 来 hack 各种设计模式也非常令人憧憬～<br>至此单例模式完成……没想到竟然引申出了这么多东西……颇有收获～<br>多例模式的话，就 new 一个 ArrayList 就可以。布局和 FlyWeight 模式有点像，不过那个的内部是一个 HashMap。</p>
<ol>
<li>Command<br><img src="https://wind2412.files.wordpress.com/2017/10/2e97319afd4ddc3eba303d08f697b9d95.jpg" alt="IMAGE">￼<br>如 UML 图可见，Client 客户端先要创建一个具有<strong>各种</strong>动作的 Receiver，虽然 GOF 只画了一个 Action()。其实内部可以有 ActionEat()，ActionDrink()，ActionPlay() 等。而 Command 的分化也可以有 ConcreteEatCommand，ConcreteDrinkCommand 以及 ConcretePlayCommand 等分化类，用于持久化各种 Action 命令。</li>
</ol>
<ul>
<li>对象模型：Command 是一个抽象类，内部有一个引用的成员 Receiver 和一个 Execute 方法，Execute 旨在调用 <code>多个 receiver.action()</code>，从而把 <code>receiver.action()</code> 延后化。即，把 <code>receiver.action()</code> 这个瞬间的调用给封装成了一个 Command 对象藉以持久化，达到推迟 <code>receiver.action()</code> 执行的最终目的。ConcreteCommand 是一个实现类。Invoker 其实就是一个 List 的封装，把所有的动作全都使用 Command 延时化，然后集结到一块，通过 <code>Invoker::invoke()</code> 来进行一块执行所有 Command 达到最终的延时操作 actions 的目的，即 MacroCommand。</li>
<li>变种：Undo and Redo：<br>可以通过和 <code>Command::Execute()</code> 方法并列编写一个 <code>Command::Undo()</code> 方法。比如 <code>Command::Execute() { receiver.turnOnLightAction(); }</code>，那么 <code>Command::Undo() { receiver.turnOffLightAction(); }</code> 就可以被如此实现。</li>
<li>用途：执行一系列延时操作；打 Log。</li>
</ul>
<ol>
<li>Adapter</li>
</ol>
<ul>
<li>类配接器：<br><img src="https://wind2412.files.wordpress.com/2017/10/e56b2aa09933ce0b15f10a8553fbcdf45.jpg" alt="IMAGE">￼<br>如 UML 图可见，Adaptee 是一个我们原本拥有的、但是和正规接口不符的要被配接的对象。我们使用多继承，继承自 Target 和 Adaptee，产生一个新的 Adapter，实现 Target 的正规接口，内部只要调用 <code>Adaptee::SpecificRequest()</code> 即可。其实十分简单。</li>
<li>对象配接器：<br><img src="https://wind2412.files.wordpress.com/2017/10/720cb5b7588de99cbba8591f81d801485.jpg" alt="IMAGE">￼<br>如 UML 图可见，Adapter 使用了<strong>聚合</strong>的方式代替了<strong>继承</strong>的方式。STL 中的容器配接器 stack 也是这么实现的。同样，在 <code>Adapter::Request()</code> 中直接调用 <code>Adaptee::SpecificRequest()</code> 即可。</li>
</ul>
<ol>
<li>Facade<br><img src="https://wind2412.files.wordpress.com/2017/10/dd29d76640a3ad798d850cf165b29ea65.jpg" alt="IMAGE">￼<br><img src="https://wind2412.files.wordpress.com/2017/10/60840b6915e310bd41f35c597047b67d5.jpg" alt="IMAGE">￼<br>外观模式更像一种软件的<strong>架构模式</strong>，因此没有 UML 图。外观模式其实在我的理解类似于<strong>模块化</strong>，通过<strong>模块化</strong>的方式来定制多种模块接口，来呈现出美观的外观。<strong>子系统内部的任何变化不会影响到 Facade 接口的变化</strong>！</li>
<li>Template Method<br><img src="https://wind2412.files.wordpress.com/2017/10/c139a82646cce7bf8eefa811e2e2cd675.jpg" alt="IMAGE">￼<br>如 UML 图可见，我们在一个抽象类 AbstractClass 中写下 <code>TemplateMethod()</code> 方法，内部指定代码逻辑的实现，分别按顺序调用 <code>PrimitiveOperation1</code> 和 <code>PrimitiveOperation2</code> 这两个方法。然后后二者使用多态，可以在子类中自由变更。但是 <code>TemplateMethod()</code> 方法永远保持不变。</li>
</ol>
<ul>
<li>应用：<code>HttpServlet</code> 中的 <code>doGet()</code>，<code>doPost()</code> 等多种方法。注意它们的命名用 <code>do-</code> 前缀开头。而且在 Servlet 的大逻辑的实现中，这些 <code>do-</code> 方法是按照 TemplateMethod 模式，按照一定的逻辑进行调用的。我们所更改的只是 <code>doGet()</code> 和 <code>doPost()</code> 的内部逻辑，但是外部的大框架逻辑并没有改变！</li>
</ul>
<ol>
<li>Iterator<br><img src="https://wind2412.files.wordpress.com/2017/10/14e23d3cdf0170d021302d2dd20071c45.jpg" alt="IMAGE">￼<br>迭代器分有内部、外部、静态、动态多种。不过大多数都是内部的“标准”迭代器。C++ STL 完全基于迭代器，让容器的遍历和容器自身完全分离开来，而且可以让外部无法知道容器内部的细节。几乎是最常用的设计模式之一，不过多解释了。</li>
<li>Compose<br><img src="https://wind2412.files.wordpress.com/2017/10/285bac2a709397cceea0e8ec0604f3725.jpg" alt="IMAGE">￼<br>组合模式最常见的就是树形结构。其实它的结构和 Decorator 有些像，但是作用是天壤之别。</li>
</ol>
<ul>
<li>例子：这个模式用例子来解释是最好的，就是文件系统。抽象的文件类就是 Component 这个抽象组件节点类，而 File 就是 Leaf，Folder 就是 Composite：它的内部含有一个 <code>List</code>，即 Folder 中可以含有 File，更可以含有其他 Folder。那么这个 UML 图就非常明了了。注意 Compose 模式的重点是树形结构就好。</li>
</ul>
<ol>
<li>State<br><img src="https://wind2412.files.wordpress.com/2017/10/f8f4476696a6fca66a1e7175002951a45.jpg" alt="IMAGE">￼<br>状态模式和策略模式比较像。只不过，Strategy 模式中，一个 state 对应多个 Strategy；而 State 模式中，多个 State 都有自己的不同的行为。<br><img src="https://wind2412.files.wordpress.com/2017/10/bff35faa62e1430a019da7c33ad1134a5.jpg" alt="IMAGE">￼<br>如上图，每个 Tool 子类都重写了 Tool 接口的四个方法。其实这和 Strategy 真的差不多。只不过 State 模式不同对象代表不同的状态，而 Strategy 总体是在一个大状态之下，而选择了不同的 Strategy 而已。</li>
<li>Proxy<br><img src="https://wind2412.files.wordpress.com/2017/10/5b47674319622e5d539b8d37bd249fa95.jpg" alt="IMAGE">￼<br>由此 UML 图可见，Proxy 和 RealSubject 都继承自 Subject 这个抽象类。都有 Request 方法。而 Proxy 的内部具有一个 RealSubject 的句柄，而 <code>Proxy::Request()</code> 的内部则是调用了 <code>realSubject-&gt;Request()</code>。即，Proxy 代理 RealSubject 来进行 RealSubject 的职务。</li>
</ol>
<ul>
<li>用途：比如网络的代理软件、操作系统的软链接、智能指针等等。</li>
</ul>
<ol>
<li>FlyWeight<br><img src="https://wind2412.files.wordpress.com/2017/10/e1582dcbab60854bcd2b7e69afcdf4485.jpg" alt="IMAGE">￼<br>FlyWeight 模式一般都自带一个工厂，工厂一般都可以是 Singleton Factory，内部一般存放一个 HashMap。其实在个人看来，C++ 的 <code>map</code> 就非常符合 FlyWeight 的观念，尤其是它重载的 <code>operator []</code>。FlyWeight 模式在向内调用 <code>FlyWeightFactory::GetKey(Key key)</code> 方法的时候，如果 key 在内部的 HashMap 中已经存放过，那么就直接取出来<strong>它的句柄</strong>，把句柄返回去。如果没有存放过，那么就把此 Key 的句柄放到 HashMap 中存放。</li>
<li>Builder<br><img src="https://wind2412.files.wordpress.com/2017/10/7188b5194eab3777f3ca91bf0e11876f5.jpg" alt="IMAGE">￼</li>
</ol>
<ul>
<li>对象模型：Builder 模式中，有一个 Director 占据主导地位。<code>Director::construct()</code> 是拼装组件的入口函数。Director 内部有一个 Builder 的 reference。Director 通过调用 <code>builder.buildPartA, builder.buildPartB, builder.buildPartC</code> 在 builder 内部产生多个组件。而这个 <code>Builder::retrieveInstance</code> 内部会由 Builder 内部所维护的成员变量 <code>partA, partB, partC</code> 来进行 construct 出一个 Product。<strong>注意：在 Builder 内部维护的成员变量仅仅是成员组件 partA/B/C，只有在 retrieveInstance 的时候才会真的生成一个 Product</strong>。</li>
<li>如果把 Director 省略掉，那么就和 Factory 差不多了。不过 construct 函数要被从 Director 中迁移到 Builder 中，并且必须在 retrieveInstance 之前调用。</li>
</ul>
<ol>
<li>Chain of Responsiblity<br><img src="https://wind2412.files.wordpress.com/2017/10/5d578416becac7dc0b76953784e5edc15.jpg" alt="IMAGE">￼</li>
</ol>
<ul>
<li>对象模型：Handler 类本质上是一个单向链表，next 即是自己。内部含有 <code>HandleRequest()</code> 方法，用来处理这个 Handler。当然，Handler 可以派生出多种类型，然后共同组成一个链。<code>HandleRequest()</code> 是会对此节点及之后的所有节点做处理的。所以只要在第一个节点处调用 <code>HandleRequest()</code> 即可。</li>
</ul>
<ol>
<li>Mediator<br><img src="https://wind2412.files.wordpress.com/2017/10/708294e4ad7e9589d9428b566c2739695.jpg" alt="IMAGE">￼<br>中介者模式主要是为了避免过度耦合的现象发生的。比如同事，在软件工程的原理中，如果没有中介人，那么同事之间要两两互相认识，太麻烦了。因此中介人即是起到保存所有同事的作用；而且每个同事之中还要保存中介人的引用。</li>
</ol>
<ul>
<li>对象模型：如上边所说，每个 College 之中要保存 Mediator；而 Mediator 中保存了所有的 Colledges。</li>
</ul>
<ol>
<li>Bridge<br><img src="https://wind2412.files.wordpress.com/2017/10/4b705ee83c2e02890742b823e1f71cb25.jpg" alt="IMAGE">￼<br>Wikipedia：如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。<br>即：将类的功能层次结构和实现层次结构分离。<br><img src="https://wind2412.files.wordpress.com/2017/10/edf285b882377c3cbe2fe46ce3d2e1705.jpg" alt="IMAGE">￼<br>如图，各个方法的实现全部放在 DisplayImpl 中去，而 Display 和 CountDisplay 中拥有 DisplayImpl 实现方法对象，可以调用 Display 的各个实现方法组合成不同的实现。比如打印一次或者五次。</li>
<li>Prototype<br><img src="https://wind2412.files.wordpress.com/2017/10/590872f2a29e7491aa7bf16caeba276f5.jpg" alt="IMAGE">￼<br>其实就是 Java 的 Cloneable 接口。根据深拷贝而形成的 Clone 方法。其实和 C++ 的 copy constructor 差不多。但是实现中要防止循环引用的深拷贝。</li>
<li>Memento<br><img src="https://wind2412.files.wordpress.com/2017/10/dcd6357fca367eab319d1da20bebbf8e5.jpg" alt="IMAGE">￼</li>
</ol>
<ul>
<li>对象模型：备忘录模式具有 Memento、Originator 以及 Caretaker 三个组件。Memento 在这里是一个 bean，内部具有一个 state 成员，标志着状态。而 <code>Originator::SetMemento()</code> 接收一个 Memento，拆包并且把 state 设置为自己的 state。而 <code>Originator::CreateMemento()</code> 会再把 state 封包成一个 Memento 返回出去。而 Caretaker 即是一个 List，存放多个 Memento。</li>
<li>注意：这三者职责非常明确。Memento 只是一个包装类，只有包装的作用；Originator 原发器具有<strong>读取备忘录</strong> 的作用；而 Caretaker 只有<strong>保存备忘录以及转发</strong>的作用，并没有查看备忘录的权限。</li>
<li>注意2：概念：宽接口 —— 正常的功能齐全的接口 窄接口 —— 啥功能都没有的接口。对 Originator 会提供 Memento 的宽接口；而对于其他的类则提供 Memento 的窄接口 —— MementoIF。而其实 MementoIF 是定义在全局的，而 Originator 中才定义了 Memento 继承于 MementoIF。也就是，只有 Originator 才能解开 MementoIF 的秘密～<br><a href="https://github.com/LexHsu/Summary/blob/master/07-DesignPatten/book/14-memento.md" target="_blank" rel="external">备忘录模式详解</a></li>
<li>对所有对象都提供正常的 Memento 的，叫做<strong>白箱 Memento 模式</strong>；而只对于 Originator 才提供正常宽接口 Memento 的，对于其他对象统统提供 MementoIF 的，叫做<strong>黑箱 Memento 模式</strong>。这种模式对于封装性非常有用！！</li>
</ul>
<ol>
<li>Visitor<br><img src="https://wind2412.files.wordpress.com/2017/10/3c931985494c55527214300c5b8d80d15.jpg" alt="IMAGE">￼<br>Visitor 模式非常有用，也很复杂。写 parser 必备。各种 AST 子节点都需要 visitor 模式来进行对子节点的一一访问，配上模板的类型推导可食用。具体代码见我的上一篇博客。</li>
<li>Interpreter<br><img src="https://wind2412.files.wordpress.com/2017/10/9da4079e58aa31abdafc117162ceaed55.jpg" alt="IMAGE">￼<br>解释器模式就略了。其实就是写一个简单的 parser。非终结符和终结符，就是类似 BNF 范式。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/10/设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wind2412">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blue_sky.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wind2412的部落格✨～">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/10/设计模式/" itemprop="url">
                  设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T15:09:10+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学习设计模式的途中，看各种网上的资料和博客，也积累了一点东西，拿出来分享一下～</p>
<hr>
<h1 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h1><ol>
<li>Singleton<br> <a href="http://blog.csdn.net/haoel/article/details/4028232" target="_blank" rel="external">很好的博客，在多线程方面讲的非常透彻。</a></li>
<li><p>Builder</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"> 	<span class="keyword">protected</span> String name;</div><div class="line"> 	<span class="keyword">protected</span> <span class="keyword">int</span> level;</div><div class="line"></div><div class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line"> 		<span class="keyword">this</span>.name = name;</div><div class="line"> 	&#125;</div><div class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLevel</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</div><div class="line"> 		<span class="keyword">this</span>.level = level;</div><div class="line"> 	&#125;</div><div class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Instance <span class="title">build</span><span class="params">()</span></span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line"> 	<span class="keyword">protected</span> Builder builder;</div><div class="line"> 	<span class="keyword">protected</span> String name;</div><div class="line"></div><div class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line"> 		<span class="keyword">this</span>.builder = builder;</div><div class="line"> 	&#125;</div><div class="line"></div><div class="line"> 	<span class="function"><span class="keyword">public</span> Instance <span class="title">construct</span><span class="params">(Args...args)</span> </span>&#123;</div><div class="line"> 	  builder.setName(args[<span class="number">0</span>]);</div><div class="line"> 	  builder.setLevel(args[<span class="number">1</span>]);</div><div class="line"> 	  ......</div><div class="line"> 	  <span class="keyword">return</span> builder.build();</div><div class="line"> 	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 和工厂方法的不同在于：builder 还有一个 director 来使用内部的 builder 来协助维持总体的组装。</span></div></pre></td></tr></table></figure>
</li>
<li><p>Prototype</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型模式实际上就在于实现 Cloneable 接口。能够让对象进行深拷贝，而不用一个一个全部重新构造。</span></div><div class="line"><span class="comment">// 不过，要注意防止循环引用的现象发生。</span></div></pre></td></tr></table></figure>
</li>
<li><p>Abstract Factory<br> <a href="http://www.runoob.com/design-pattern/abstract-factory-pattern.html" target="_blank" rel="external">抽象工厂</a></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">抽象工厂是 “工厂的工厂”。这类抽象的工厂通过传入的参数来返回工厂对象。因而这类抽象工厂是 “工厂的产生器”。</div><div class="line">工厂内部可以产生不同类型的对象。这些对象在被继承的时候，可以把没有关系但是却又不得不继承的方法设置为空方法。</div></pre></td></tr></table></figure>
</li>
<li><p>Factory<br> <a href="http://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="external">工厂</a></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">工厂类顾名思义，其实就是创建一个工厂来通过传入的参数来返回创建好的产品对象。比较常用。这个工厂只生产一个借口下的多个子类。而 Abstract Factory 可以生产多个不同接口类下的子方法。</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h1><ol>
<li><p>Strategy</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用[继承体系]，继承同一个接口，只不过每种子类有不同的实现。然后通过把这继承体系的对象当做参数，可以选择不同的算法。其实就像 C++ STL 中的非标准的 std::add, std::sub, std::mul 等等。每个重载 operator() 都是不同的算法。通过把这些 adaptor 传递给接受他们的函数，就可以相当于使用这些算法了。</span></div></pre></td></tr></table></figure>
</li>
<li><p>State</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// State 首先是一个接口而引发的继承体系。State 会有多种。</span></div><div class="line"><span class="comment">// 其实吧，如果我有一个 boy 对象，他的状态发生了改变的话，明明是 boy 自身的变动，却由程序员[我]来手动调用 boy.setState(new BadState()) 来帮他上状态，确实很诡异...... 所以这里，为了符合语义也一定要反过来。也就是，状态 State 占主导，接收参数来改变 boy。即：</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Boy boy)</span> </span>&#123;</div><div class="line">    boy.setState(<span class="keyword">this</span>);   <span class="comment">// 还是这样顺眼一些......</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Chain of Responsibility (责任链模式)<br> <a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="external">真是玄奥……并不明白它会被应用在哪里……</a></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 其实本质上是一个链表结构。然后每个节点被封装了一个 level，节点内部有一个处理责任链的方法，这个方法是递归实现的，接收另一个 need_level 参数，会对每个接下来的节点进行处理。整个链表上 this.level &gt; need_level 的节点都将会被忽略掉。也就是传入参数 need_level 是紧急的程度。紧急程度越高，就越会激活大部分的责任链了。</span></div><div class="line">这个还要好好看一看复习下咯。</div></pre></td></tr></table></figure>
</li>
<li><p>Interpreter<br> <a href="http://www.runoob.com/design-pattern/interpreter-pattern.html" target="_blank" rel="external">解释器模式……parse 成 AST……</a></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">额呵呵呵......写一个解释器 ????? 有待考察......</div></pre></td></tr></table></figure>
</li>
<li><p>Command<br> <a href="http://www.runoob.com/design-pattern/command-pattern.html" target="_blank" rel="external">命令模式：把函数的执行包装成一个对象！</a></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这样把 “函数的执行动作” 变得 “实体化” 了，就可以实现数据库的事务等等了。这样，任务的执行都是被记录的，而且可以批量进行执行。</span></div><div class="line"><span class="comment">// 统括思想：创建一个具有继承体系的 “命令对象”，本质是一个接口继承而来。这个通用的统一接口下，类似策略模式以及配接器模式，会对要被执行的函数进行一个封装，即把不同的策略封装在不同的类产生的对象中，但是接口统一地去进行【持久化】。然后，如果要执行一套连续的动作的话，只需要把保存在 list 中的这些对象统一取出来，再进行逐一遍历，然后调用统一的接口函数即可。</span></div><div class="line">【在学习设计模式的时候，如果想要学得深入的话，就要先想想如果是自己的话，会怎么做。然后再学习前人们的成果，最后还一定要多加重复才行。】</div><div class="line"><span class="comment">// 比如我有一个类，它有多种动作：</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Action</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 为了把这些瞬时的 “动作” 持久化成为 “永久的”，我们创建一套 Order (命令)类组合：</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Order</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">executeAction</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyOrder</span> <span class="keyword">implements</span> <span class="title">Order</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> Action a;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BuyOrder</span><span class="params">(Action a)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = a;</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">executeAction</span><span class="params">()</span></span>&#123;</div><div class="line">    a.buy();      <span class="comment">// 这样的话，一个 “过程” 就被封装成为了一个类对象了！！再包装一层永远是解决问题的策略。</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellOrder</span> <span class="keyword">implements</span> <span class="title">Order</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> Action a;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SellOrder</span><span class="params">(Action a)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = a;</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">executeAction</span><span class="params">()</span></span>&#123;</div><div class="line">    a.sell();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EatOrder</span> <span class="keyword">implements</span> <span class="title">Order</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> Action a;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EatOrder</span><span class="params">(Action a)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = a;</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">executeAction</span><span class="params">()</span></span>&#123;</div><div class="line">    a.eat();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Observer</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以对应 Java GUI 中的 “通知” 的 action。适用于一个组件发生了改变，然后可以对多个其他的组件进行主动通知的设计模式。当然，需要这被通知的多个组件具有相同的接口才行！！比如，都实现了统一的 update() 方法！要不，如果方法签名都不统一，上哪去调用去......</div></pre></td></tr></table></figure>
</li>
<li><p>Memento (备忘录模式)<br> <a href="http://www.runoob.com/design-pattern/memento-pattern.html" target="_blank" rel="external">Memento</a></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">可以适用于游戏存档的场合。</div><div class="line">里边有 <span class="number">3</span> 个类：Memento(包装一个 state 的结构)、Originator(产生 Memento 的工厂)、CareTaker(一个 Memento 的 list)。记住这三点，就非常简单。而 CareTaker 是通过操纵 Originator 来间接产生 Memento 对象存档的。</div></pre></td></tr></table></figure>
</li>
<li><p>Iterator</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">STL 中全部如此。略了。</div></pre></td></tr></table></figure>
</li>
<li><p>Template Method</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">在 <span class="keyword">abstract</span> 基类中定义一个 <span class="keyword">public</span> <span class="keyword">final</span> 方法作为指定好的模板算法骨架，这个骨架会按某种顺序调用此类的其他方法。而继承此 <span class="keyword">abstract</span> 类的子类，只需要重写这些 “其他方法” 就可以了。</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">executeInOrder</span><span class="params">()</span></span>&#123;</div><div class="line">    first();    <span class="comment">// 执行模板已经定义好，**必须**按照顺序执行。子类只需要重写 first(), second(), third() 即可。</span></div><div class="line">    second();</div><div class="line">    third();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Visitor<br><a href="https://zhuanlan.zhihu.com/p/25581709" target="_blank" rel="external">Parser 的 Visitor 设计模式</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 轮大讲的非常好～</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IVisitor</span>&#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~IVisitor() = <span class="keyword">default</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ValueExpr *node)</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(AddExpr *node)</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(MulExpr *node)</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expr</span>&#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~Expr() = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor *visitor)</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueExpr</span> :</span> <span class="keyword">public</span> Expr&#123;</div><div class="line">  <span class="keyword">public</span>:           <span class="comment">// 注意：数据全是 public 的。如果要设置 private，请设置 IVisitor 为友元。</span></div><div class="line">    <span class="keyword">double</span> value;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor *visitor)</span> override</span>&#123;</div><div class="line">      visitor-&gt;visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddExpr</span> :</span> <span class="keyword">public</span> Expr&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;Expr&gt; x;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;Expr&gt; y;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor *visitor)</span> override</span>&#123;</div><div class="line">      visitor-&gt;visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulExpr</span> :</span> <span class="keyword">public</span> Expr&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;Expr&gt; x;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;Expr&gt; y;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor *visitor)</span> override</span>&#123;  <span class="comment">// 接受参观者</span></div><div class="line">      visitor-&gt;visit(<span class="keyword">this</span>);   <span class="comment">// 参观者进行访问动作，即改写 visitor 自身的 result</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvalVisitor</span> :</span> <span class="keyword">public</span> IVisitor&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">double</span> result;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">call</span><span class="params">(Expr *node)</span> </span>&#123; <span class="comment">// visitor 呼叫(通知，也就是按门铃)被参观者叫他接受 (accpet) 自己 (给自己开门)</span></div><div class="line">      node-&gt;accept(<span class="keyword">this</span>);</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ValueExpr *node)</span> override</span>&#123;</div><div class="line">      result = node-&gt;value;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(AddExpr *node)</span> override</span>&#123; <span class="comment">// 已经进入了 AddExpr</span></div><div class="line">      result = call(node-&gt;x.get()) + call(node-&gt;y.get()); <span class="comment">// 还想访问 AddExpr 内部的两个元素。</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(MulExpr *node)</span> override</span>&#123;</div><div class="line">      result = call(node-&gt;x.get()) + call(node-&gt;y.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Eval</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Expr&gt; node)</span> </span>&#123;</div><div class="line">  EvalVisitor visitor;</div><div class="line">  node-&gt;accept(&amp;visitor); <span class="comment">// accept 才是真的入口？？？</span></div><div class="line">  <span class="keyword">return</span> visitor.result;  <span class="comment">// 其实这两句写成一句 call 也行。不过一般 call 都是被设置成为 private 的吧。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Mediator (中介者模式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 中介者模式顾名思义，其实就是提供了一个中介，来降低双方通信的复杂度。在双方要进行通信的时候，都会调用中介者来显示信息。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chatroom</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">showMessage</span><span class="params">(String msg)</span> </span>&#123; sysout...; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">    Chatroom.showMessage(msg);    <span class="comment">// 这样。直接调用中介者 Chatroom 显示在 Chatroom 的屏幕上。</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  User jack = <span class="keyword">new</span> User();</div><div class="line">  User tom = <span class="keyword">new</span> User();</div><div class="line">  jack.sendMsg(<span class="string">"hello!"</span>);</div><div class="line">  tom.sendMsg(<span class="string">"hi!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h1><ol>
<li><p>Decorator<br> Java IO 中经常用到。BufferedInputStream 等其实就是对底层 IO 的封装。<br> 在继承体系当中，<strong>子类含有一个接口类的对象，虽然这个子类也是接口类的对象。</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Worker</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">implements</span> <span class="title">Worker</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span> <span class="keyword">implements</span> <span class="title">Worker</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> Worker worker;  <span class="comment">// 内部有一个接口对象，可能是 Son。</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Mother</span><span class="params">(Worker worker)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.worker = worker;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">    worker.work();  <span class="comment">// 基于内部的 worker 写好的 work 进行 [装饰扩展]。</span></div><div class="line">    ... <span class="comment">// 扩展</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Proxy</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 套路和上边的 Decorator 很像，不过它的目的并不是用于加强，而是用于控制。</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Worker</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">implements</span> <span class="title">Worker</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerProxy</span> <span class="keyword">implements</span> <span class="title">Worker</span></span>&#123;  <span class="comment">// 也要继承 Worker。因为要保持接口一致。</span></div><div class="line">  <span class="keyword">private</span> Son son = <span class="keyword">null</span>;   <span class="comment">// 对象是固定的 Son。因为是此类是针对 特定类 特化的 代理类。</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WorkerProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// nothing</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (son == <span class="keyword">null</span>) &#123;</div><div class="line">      son = <span class="keyword">new</span> Son();    <span class="comment">// 没有的话就创建。相当于 Lazy Singleton。</span></div><div class="line">    &#125;</div><div class="line">    son.work();   <span class="comment">// 不增强。而是直接调用 son。这就是个代理，要尊重原作，并不像 Decorator 一样加以修改。</span></div><div class="line">                  <span class="comment">// 第二次调用此 work 方法，son 就不必 new 了。这点和 Decorator 差不多。</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Composite</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">类比于文件系统。</div><div class="line">所有的一切，包括容器类全都继承自同一个接口。适用于树形结构。</div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">File</span> </span>&#123;</div><div class="line">  File[] files;</div><div class="line">  ...</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TXT</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PNG</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Bridge<br> <a href="http://www.runoob.com/design-pattern/bridge-pattern.html" target="_blank" rel="external">Bridge</a></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 调用方式：(先写出调用方式可能更好一些。)</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">   Shape redCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>, <span class="number">10</span>, <span class="keyword">new</span> RedCircle());</div><div class="line">   Shape greenCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>, <span class="number">10</span>, <span class="keyword">new</span> GreenCircle());</div><div class="line"></div><div class="line">   redCircle.draw();</div><div class="line">   greenCircle.draw();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 其中 Circle 是直接继承于 Shape 的。RedCircle 和 GreenCircle 是直接实现于 DrawAPI 的。</span></div><div class="line"><span class="comment">// Circle.draw() 的时候，内部会直接调用成员变量 RedCircle.drawAPI() 和 GreenCircle.drawAPI() 来进行转发。</span></div></pre></td></tr></table></figure>
</li>
<li><p>Adapter</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">配接器模式，在 STL 中用得非常多。比如 vector -&gt; stack，还是 std::bind2nd 等等。</div></pre></td></tr></table></figure>
</li>
<li><p>Flyweight (享元模式)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">其实就是使用 HashMap 来保存和提取公有对象而已。和 STL 的 map 的 operator[] 原理简直一模一样。</div><div class="line">当然，非常有可能和 [工厂模式] 以及 [单例模式] 联协使用。可以用一个 Singleton 的 Factory 内部包装一个 HashMap 的意思～</div></pre></td></tr></table></figure>
</li>
<li><p>Facade (外观模式)<br> <a href="http://www.runoob.com/design-pattern/facade-pattern.html" target="_blank" rel="external">Facade</a></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 Shape 这个接口产生 Circle，Rectangle 以及 Square 三个类型，共有 draw() 接口。</span></div><div class="line"><span class="comment">// 为了隐藏逐个调用的复杂性，使用一个更高层次的类 ShapeMaker 来封装，client 不必知道系统内部的复杂性，整个系统只需要提供一个封装好的 “接待员” 即可。</span></div><div class="line"></div><div class="line"><span class="comment">// 这段代码比较能够反映核心，因而拷贝过来。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMaker</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> Shape circle;</div><div class="line">   <span class="keyword">private</span> Shape rectangle;</div><div class="line">   <span class="keyword">private</span> Shape square;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ShapeMaker</span><span class="params">()</span> </span>&#123;</div><div class="line">      circle = <span class="keyword">new</span> Circle();</div><div class="line">      rectangle = <span class="keyword">new</span> Rectangle();</div><div class="line">      square = <span class="keyword">new</span> Square();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</div><div class="line">      circle.draw();</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</div><div class="line">      rectangle.draw();</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSquare</span><span class="params">()</span></span>&#123;</div><div class="line">      square.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Java-字节码-class-文件解析：写一个-javap-工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wind2412">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blue_sky.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wind2412的部落格✨～">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/08/Java-字节码-class-文件解析：写一个-javap-工具/" itemprop="url">
                  Java 字节码 .class 文件解析：写一个 javap 工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T21:51:18+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="我们的题目"><a href="#我们的题目" class="headerlink" title="我们的题目"></a>我们的题目</h1><p>最近闲着没事想要了解一下 Java .class 文件的结构。然后想要对它进行一下解析。毕竟解析二进制码不是一件特别麻烦的事情，以前也干过，其实是非常有意思的。因此打算按照 JVM 规范对 .class 进行解析。总共用 C++ 写了不到 3k 行代码，应该能够按照 JVM 规范所说的进行完美的解析了。其实一点也不难，按照 JVM 规范的 $4 第四章给定的数据结构和规范进行直接对字节码进行解析即可。<br>下面说一下详细的方法和实践步骤。<br>对 .class 文件的解析是非常轻松加愉快的，如果想要看代码的话，请移步 <a href="https://github.com/wind2412/javap/blob/master/class_parser.h" target="_blank" rel="external">wind2412的github – 对 .class 文件进行解析</a> 我的代码仓库进行查看完整的代码。其实头文件就是 JVM 规范的所有数据结构的集合，<code>#define</code> 的是各种类型的变量结构。当然，为了解析愉快，我在每个数据结构的内部全都塞进去了一个的 <code>friend std::ifstream &amp; operator &gt;&gt; (std::ifstream &amp; f, TYPE &amp; i);</code> 结构进行结构式的从 .class 文件通过输入流进行读取字节码来填充进数据结构的内部。那我就让我们进入愉(wu)快(liao)的 .class 文件解析之旅吧～<br>本文的定位并不在于一步一步指导要怎么 parse .class file。而是要把踩过的坑都列出来。毕竟网上的菊苣们 hack 这个的也有不少，网上这方面文章还是有很多的，我没有必要重复造轮子（大雾。因此，本篇的主旨在于对想要进行这项工作的童鞋进行一个宏观的 “坑的解说（逃”。</p>
<h2 id="需要之物"><a href="#需要之物" class="headerlink" title="需要之物"></a>需要之物</h2><ol>
<li>JVM 的规范，最好要 SE 8 版本的规范，因为 SE 7 中有的部分和 8 不一样，改动其实也不太小（。当然为了效率我看的是中文版的，中文版的有不少错误QAQ。最后还是看的英文进行的解析。而且毕竟英文版的放在 oracle 官网上，因此数据结构可以直接进行复制粘贴（雾。</li>
<li>C++ 基本语法的熟悉即可。当然用 Java 也不是不可以，但是据说有 Java 有内置的一个什么 xxxClassParser 在 sun 包下，可以直接经过人家的 API 进行解析的（逃。Java 毕竟全是引用，在 parse <code>annotation</code> 那里要好办很多QAQ，用 C++ 必须强行使用指针咯。</li>
<li>java 环境。你必须要有 <code>javap</code> 和 <code>hexdump</code> 两样神器：一个是直接把 .class 文件反汇编，尤其是 <code>javap -verbose</code> 命令，你几乎可以查看到非常完整的反汇编代码，解释得非常清楚；另一个是直接暴力查看 .class 文件的字节码，两者强强联合，使用更佳！！而我的代码的定位，就是写一个 <code>javap -verbose</code> 工具。力争输出和 <code>javap -verbose</code> 一样～</li>
</ol>
<h2 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN!"></a>BEGIN!</h2><p>那么我们就开始吧！</p>
<ol>
<li>预读。首先我们要知道，写 parser 的话，如果想要避免回溯，就一定要采取预读 <code>peek</code> 的策略。Java 官方在 .class 文件的制作上，也是采取了 <code>peek</code> 的策略。比如 LL(1) 文法，就是采取预读 1 个 <code>token</code> 的方法。而 LR(0) 文法就是预读 0 个 <code>token</code>。不过字节码毕竟是 <code>bytecode</code>，那么这个 <code>token</code> 当然就是一个 <code>byte</code> 啦！当然随着往下写我们就知道，因为一个 byte 最多也就能表示 256 个数字，因此可能太小了。要表示类别的数量，很有可能需要两个 bytes。所以我在里边写了 <code>peek1()</code> 和 <code>peek2()</code> 两个方法来进行预读工作。有了 C++ 的流，我们可以非常轻易地进行从流缓冲的读取。还是非常赚的～</li>
<li>注意你机器是大端序还是小端序。我的 mac 是小端序的。因此读入的时候，<strong>保存在变量中</strong>是反向存放的。所以，这样就会引发 “读的是反的” 的情况。因此，在 *nix 环境下，我们可以引用 POSIX 规范的 <code>#include &lt;arpa/inet.h&gt;</code> 头文件，使用其中的 <code>htons()</code> 和 <code>htonl()</code> 函数进行比特的逆转。当然，这两个函数其实真正是用在网络编程当中的。在 <code>read2()</code> 和 <code>read4()</code> 中，我用到了这两个函数。</li>
<li>关于 unicode。因为 Java 字节码全都是使用 Java 改进的 UTF8 编码进行存放的。如果我们要保存的话，就一定要将其转为 Unicode。Java 的 String 本身就支持 Unicode，自然不必多说，但是 C++ 的 std::string 不行啊……因为它某种意义上讲根本就不是一个 string……顶多算是一个 char[] 数组。但是我们有 std::wstring，它是按照 Unicode 进行存放的。其实 Java 毕竟是 Unicode，我们可以使用中文编程的，比如 <code>class 蛤蛤 { public static int 膜 = 4; }</code>，这类的情况也需要我们进行考虑。当然，用通用的 Unicode 准没错就是了～</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>JVM 规范的第四章把数据结构全用伪代码列给我们了。当然，这其中有很多坑。我会一一列举出来。</p>
<ol>
<li>在 Java 的规范中，有非常多的继承关系。而如何对这些继承的结构进行识别，我们就需要用到 <code>peek</code> 来进行 <code>distribute</code>。也就是，使用 “前看一个或者两个字符” 来进行选择到底该选择哪个类进行使用。举个例子，比如常量池 <code>constant_pool</code>，我们就可以看代码：<a href="https://github.com/wind2412/javap/blob/master/class_parser.h#L79-L160" target="_blank" rel="external">constant_pool 的继承关系</a>，这个 <code>cp_info 结构体</code> 就是一个基类。预先读入 <code>peek</code> 一个一字节的 <code>tag</code> 之后，我们就会按照 <code>tag</code> 的大小，按照这几个 <code>#define</code> 的变量，见 <a href="https://github.com/wind2412/javap/blob/master/class_parser.h#L34-L47" target="_blank" rel="external">constant_pool 的 tags</a>，来进行选择子类的类别，并且按照子类内部的成员向内进行填充 bytecode。这之中比较坑的是 <code>long</code> 和 <code>double</code>，因为他们在常量池当中要占据两个位置……而正常的变量都占据一个位置……我还没有实现过简单的 JVM，并不知道这么做的深意……而且常量池的索引是从 1 开始的，而不是从 0 开始，我也并不明白这个的深意……不敢妄测不敢妄测。不过这个是比较坑的部分，必须小心谨慎，否则可能会一调试调试一个晚上（QAQ。</li>
<li>如果遇到类内部的数组(而且不定长度，是按照类内部的另一个成员变量的数值来当做长度的)，这样，编译过程中长度不确定的数组是不被允许的。必须要等到运行时才能进行。因此，必须要使用 <code>new</code> 来在堆上在运行时分配。其实这里是比较好考虑到的。但是，由于 C++ 的 RAII 特性，我们就要在这样的类中写析构函数…… 这样不断的申请释放不断 copy 代码实在是累死了QAQ……</li>
<li>常量池 parse 完了之后，我们可以说是完成了 1/4 的工作吧。不过如果常量池 parse 完了，后边的工作难度就大大降低了。我们就可以 parse field and methods and interfaces。这三者其实都差不多，只不过 method 是最难的。因为内部含有大量的运行时字节码。这样的字节码将会是非常麻烦的，因为 <code>java -verbose</code> 的输出非常麻烦……其实截止到现在，我还并没有写完，因为实在是想要和它官方的 output 一模一样的话，实在是工作量奇大，说不定要到 4k 行去……而且要非常明确各个字节码的意义才行。等以后写一个 simple jvm 的时候再说吧。那么，比较坑的地方其实并不在于别的，而是在于 <code>annotation(注解)</code> 的解析。因为如果你仔细观察过 <code>annotation</code> 的<a href="https://github.com/wind2412/javap/blob/master/class_parser.h#L467-L505" target="_blank" rel="external">数据结构实现</a>，我们就会发现……其实 <code>element_value</code> 结构体的内部有一个 <code>value_t*</code> 的指针，当然这个 <code>value_t</code> 是继承体系中的根类。它可以变成 <code>annotation</code> 子类。而 <code>annotation</code> 结构体的内部又有着 <code>element_value</code> 的对象……你没看错这个其实是循环的。要读入必须要递归。读者看到这里，可能会以为，“没啥打不了的反正就是递归啊～”，会有这种想法不奇怪……毕竟我说得比较简单（逃，其实 java 中还有<a href="https://github.com/wind2412/javap/blob/master/Annotations.java#L22" target="_blank" rel="external">这种用法</a>，即像这种一样，我还是列在下边吧： <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@IA</span></div><div class="line"><span class="meta">@IB</span>(name = <span class="string">"ha"</span>)</div><div class="line"><span class="meta">@IC</span>(name = <span class="string">"ok"</span>, a = <span class="meta">@IA</span>, b = &#123; <span class="meta">@IB</span>(name = <span class="string">"a"</span>), <span class="meta">@IB</span>(name = <span class="string">"b"</span>), <span class="meta">@IB</span>()&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span> <span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Java 的 <code>annotation</code> 赋值 <code>annotation</code> 的猥琐用法……. oh 如果有的童鞋说 “我已经知道了”，那么请忽略我说的话 QAQ，我也是在写程序的过程中才发现这个奇技淫巧的用法的……QAQ，尤其是这货在 <code>javap -verbose</code> 下所产生的反汇编字符串是：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RuntimeInvisibleAnnotations:</div><div class="line">	0: #10()          // IA，就是 #10 (是常量池编号) 的构造函数式空构造函数。</div><div class="line">	1: #11(#12=s#13)  // IB，就是 #11 的构造函数是 #12，也就是 name，它的构造函数的参数是 #13 &quot;ha&quot;，当然，&quot;s&quot; 代表的语义是 #13 是一个 Unicode 的 String。如下文一般的 &quot;@&quot; 表示参数是一个 annotation(递归的)。这些都可以在文档中查到。</div><div class="line">	2: #14(#12=s#15,#16=@#10(),#17=[@#11(#12=s#16),@#11(#12=s#17),@#11()])</div></pre></td></tr></table></figure></p>
<p>对照着上边的源代码看，我们可以知道：<code>IA, IB, IC</code> 这三个 <code>RuntimeInvisibleAnnotations</code> 其实在反汇编码中代表着 <code>#10, #11 和 #14</code>。而后边跟随着的括号即是构造函数。注释我已经写在了后边，当然，最后一个我故意没有写，还请看官自行考虑～ 这部分的代码在<a href="https://github.com/wind2412/javap/blob/master/class_parser.cpp#L1788-L1848" target="_blank" rel="external">这里</a>，可以看到用了一个函数内部套着一个内部的 lambda 表达式。lambda 表达式内部有多个分支，其中如果是把 annotation 赋给 annotation 递归的情况，就会由内部的 inner lambda 呼叫外部的函数；如果要是最后一种情况，即是把数组赋给 annotation 的话，由于 .class 文件的数据结构内部表示问题，我们会让 inner lambda 递归呼叫自身。这个问题就留给读者吧～</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>搞定了上边这些，估计也到了尾声了。放一张图来表示内心的鸡冻（逃：<br>    <img src="https://wind2412.files.wordpress.com/2017/10/img_0966.jpg?w=816&amp;h=1088&amp;zoom=2" alt="IMG_0966.JPG"><br>那么这篇文章也要结束了～接下来两个月，我打算写一个 simple STL，然后仔细研读虚拟机规范，实现一个简单的 JVM。就这样吧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/26/Effective-STL-笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wind2412">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blue_sky.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wind2412的部落格✨～">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/26/Effective-STL-笔记/" itemprop="url">
                  Effective STL 笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-26T19:56:03+08:00">
                2017-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第零章-前言"><a href="#第零章-前言" class="headerlink" title="第零章 前言"></a>第零章 前言</h1><hr>
<p>建议：Effective STL 这本书非常有深度，在细节上尤为体现。建议读这本书之前，先仔细研读侯捷老师的《STL 源码剖析》，然后好好研究 sgi-stl 源码。对大致框架掌握仔细之后，可以阅读《Effective STL》加以查缺补漏以及更加精进。</p>
<hr>
<h1 id="第一章-容器"><a href="#第一章-容器" class="headerlink" title="第一章 容器"></a>第一章 容器</h1><hr>
<ol>
<li>[1] vector、string (其实还应该有基于 heap 的 priority_queue 和 queue)这类连续容器的插入、删除会对所插入的位置的后边的所有迭代器、指针以及引用变得无效。而且，如果插入操作导致了容器扩容，将会使整个容器的迭代器、指针和引用全部失效。因此，一定要默认“vector、string 的插入和删除一定会造成所有迭代器、指针、引用失效”，这样才不会发生错误和 UB 行为。 [2] list、map、set、multimap、multiset 等等基于节点的容器(链表、红黑树) 上的插入、删除操作从来不会使任何迭代器、指针和引用发生无效(除了你指向一个正在删除的元素)。因此可以尽情使用。 [3] deque 比较特殊，它是唯一一个 “当插入操作发生在开头/末尾的时候，迭代器会发生无效，但是指针和引用不会发生无效的 STL 标准容器”。因为它基于浅拷贝来进行内存的复制。</li>
<li>对 vector 等的使用封装化。typedef vector<int> CCList; 这样以后 vector 可以换成 deque。必要的使用使用 template class 来进行封装细节。</int></li>
<li>STL 容器全是复制来实现的。但是这对于继承和多态比较麻烦，因为传入 vector\<shape\> 的 Rect 对象的特有信息会被 slice(剥离)，而且无法找回。这样的话就必须【传入指针】，即使用 vector\<shape*\> 来进行操作，这样才能够一劳永逸。当然，指针的释放是头痛的问题。我们可以使用智能指针～～</shape*\></shape\></li>
<li>调用 empty() 来代替 size() == 0，因为 empty() 只是比较 begin 和 end 迭代器，但是 size() 需要现算。size() 是 O(n) 的本质是由于 STL 牺牲了 size() 的时间复杂度，把 O(1) 的时间复杂度给了 splice()。这两个的时间复杂度必然有一个是 O(1) 一个是 O(n)。因为 splice 的参数是两个迭代器，他们之间元素的数目是不知道的。如果要更新 size，就必须遍历。如果想要保证 splice 的 O(1)，就不能去遍历，而牺牲掉 size。这种矛盾构成了 size 可能是 O(n) 实现的格局。</li>
<li>很重要的 v.assign(iter1, iter2) 区间分配函数。意思就是把 v 变成 iter1 ～ iter2 之间的东西。</li>
<li><code>list&lt;int&gt; l(istream_iterator&lt;int&gt;(f), istream_iterator&lt;int&gt;());</code> 这样写并不可行。应该这样写：<code>list&lt;int&gt; l((istream_iterator&lt;int&gt;(f)), istream_iterator&lt;int&gt;());</code>。这是 C++ 编译器的问题。</li>
<li>如果 使用 vector<t*> 的话，注意 v.push_back(new T) 在 v 析构的时候，T 是不会被析构的。这样就会内存泄漏。于是，我们【一定要】vector<shared_ptr<t>&gt; ！！</shared_ptr<t></t*></li>
<li>不要使用 vector<auto_ptr<t>&gt;。因为这个智能指针是会【转移】对象所有权，当 v.push_back(new T) 的时候没啥问题，但是当 T temp = v[3] 的时候，会造成 v[3] 的所有权被转移到了 temp，而造成 v[3] 本身 UB。</auto_ptr<t></li>
<li><p>很重要！！选择迭代器删除的方法，还要保证迭代器不失效——可以结合 clause 1 一起看！！[1] 对于连续内存的容器 vector、string、deque(多个连续内存的容器)，可以使用 erase-remove 的手段清除。即，<code>v.erase(remove(v.begin(), v.end(), 3), v.end())</code>。[2] 对于标准关联容器 set、multiset、map、multimap 的时候，<strong>使用任何名为 remove 的方法都是错误的</strong>。因为他们内部没有 remove 方法，只有 erase 方法。且使用 std::remove 可能会覆盖容器的值甚至是破坏容器。因为 std::remove 会把被删除的值通过迭代器交换到容器后边，而这 4 个容器全基于红黑树，任何的移动都会导致树结构的崩溃。可以见第 32 条。所以应该使用 c.erase(3)。[3] 对于 list 来说，两种方式都是可行的。但是<strong>一般来说都会使用 vector 和 string 的 erase-remove 方法。不造为啥……</strong>。[4] 如果是条件删除 remove-if 的话，对 [1] 而言只要改成 erase-remove_if 即可，很简单。对于 [3] 的话却变成了使用类似关联容器的 l.remove_if() 更加简单了。不过对于 [2] 的话，就要使用一些技巧。因为虽然关联容器的迭代器几乎不会失效，但是在删除元素的时候指向该元素的迭代器是肯定会失效的。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; c;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.begin(); i != c.end(); i ++) &#123;  <span class="comment">// 使用 auto i。该拷贝就要拷贝。使用 auto &amp;&amp; 因为 iterator 本身并没有 new 内存，因此效率是一样的，也是浅拷贝全部东西。</span></div><div class="line">  <span class="keyword">if</span>(...) c.erase(i);   <span class="comment">// 但是很不幸这是错的。因为 i 被删掉的时候已经失效。这时 i 有可能是未知值，也有可能指向其他地方。而且树也会发生旋转，结构发生改变。所以我们要修改如下：</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 改成：</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = c.begin(); i != c.end(); ) &#123;    <span class="comment">// 需要自己写遍历循环了。因为 vector 的 erase 一次能删一堆(因为 remove 把该删的都调到最后了)，而 set 的 erase 一次只能删除迭代器指向的那个(因为 set 不能 remove)，但是其实这两者的 erase 接口都是一样的，都可以删除一个 iter 或者删除一整个 iter1～iter2 的区间。区别仅仅在于有没有 remove 来扶一下。且 vector::erase() 有返回值 iter，返回被 remove 的元素的下一个；而 set::erase() 返回 void。</span></div><div class="line">  <span class="keyword">if</span>(...) c.erase(i++); <span class="comment">// 这样的变换是非常正确的。不过乍一看好像是错的而已。容易误解成 “这不是 c.erase(i) 然后 i 再 ++ 么？不是和原先一样吗” 的感觉。不过这是错觉。其实 i 是一个 iterator class。当 i++ 的时候，其实是先调用了 operator ++ (int n)。而后内部迭代器先发生了改变，然后返回一份 copy 的发生变化前的 iterator。然后 c.erase(i)，这时树的结构会发生变化。这时我们参照 clause [1]，对于关联容器的插入和删除不会让迭代器、引用和指针发生失效。而且增加过的 i 也确实牢牢地指向下一个节点，纵使树发生了旋转。(因为树发生旋转仅仅是因为树节点的内部指针变化了，而节点自身并没有发生内存位置的移动)。对数据结构掌握深入的话，就会明白这一切。</span></div><div class="line">  <span class="keyword">else</span> i ++;    <span class="comment">// 我写得太多了......别忘了这还有一句（</span></div><div class="line">  <span class="comment">// 且，其实我们对 i++ 这个操作一直具有着误解。c.erase(i++) 并不等于 c.erase(i) 然后 i++ 啊。而是 i 的迭代器正体已经变化了，而又返回一个过去的 temp_i 而已。其实这是一共两份副本。其实原先学 C 语言的时候，理解的 int i = 0; func(i++) 以为是先 func(i) 然后 i++ 呢......虽然结果上来讲是对的，但是语义却是完全错的......因为【当时 i 就变了，只不过是返回副本而已，造成了看起来好像是 i 在做完 func(i) 之后而在下一句之前才 ++ 的假象。】</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> [5] 如果要打 log 记录被删除元素的话，由于关联容器是一个一个删，反而好打 log。而 vector、string 是批量删除，反而需要改成一个一个删除的形式才能打 log。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 既然要一个一个删，那就只能使用删除单个迭代器的 erase 了。但是要注意 vector 删除元素会造成迭代器失效！因此，我们需要使用 vector&lt;T&gt;::erase 的返回值，该返回值是被删除元素的下一个元素的有效迭代器。</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = c.begin(); i != c.end(); ) &#123;</div><div class="line">  <span class="keyword">if</span> (...) &#123;</div><div class="line">    Log &lt;&lt; .... &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    i = c.erase(i);   <span class="comment">// 重点！！</span></div><div class="line">  &#125; <span class="keyword">else</span> ++i;   <span class="comment">// 记住正常使用迭代器的时候，尽量用 ++i 而不是 i++。因为 i++ 要创建一个副本！！太浪费了！！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最重要！！这涉及到如何去编写一个 Allocator！！见第 10 条末尾！！记住提供 nested-rebind 模板，然后 allocate() 接收参数为要分配的对象个数，而不是字节总数！！和 sgi 的 simple_allocator 的外层包装(STL规范)一样！！但是底层实现随你便。而且，必须返回 T* 指针！！<a href="http://www.josuttis.com/cppcode/myalloc.hpp" target="_blank" rel="external">规范的allocator写法</a></p>
</li>
<li>自己编写的多个 allocator 要等价。allocate/construct/destruct/deallocate，而且不能有 non-static 成员变量，一定要实现“共享”。</li>
<li>STL 标准规定：[1] 多个线程对同一个容器的“读”操作是安全的。但是之中不能写操作。[2] 多个线程对不同的容器做写入操作时安全的。?????????????<br>【重要：】我们可以把锁的 lock(container) 封装到一个 Lock 类的 constructor 中，然后把 unlock(container) 封装到 Lock 类的 destructor 中。这样的话，Lock 的构造函数就需要接收一个 Container，内部存放一个 private 的 Container &amp; 引用。然后这样，就不用每次都手动调用 lock 和 unlock 了。而且可以自动析构，还是异常安全的。因为即便抛出异常，只要 catch，Lock 类就会执行析构的。</li>
</ol>
<hr>
<h1 id="第二章-vector-和-string"><a href="#第二章-vector-和-string" class="headerlink" title="第二章 vector 和 string"></a>第二章 vector 和 string</h1><hr>
<ol>
<li>string 一般使用引用计数来进行优化。而 vector 强制不能使用引用计数。但是，引用计数本身又会对多线程安全造成问题，因此还要手动进行线程安全处理，这就会让 string 在多线程的环境下的效率还不及不加引用计数的版本。想要避免的话，[1] 看 string 有没有手动关闭引用计数的接口 [2] 使用 vector<char> 来代替 string 也是可以的。</char></li>
<li>[1] 在 <code>for(int i = 0; i &lt; 1000; i ++) v.push_back(...);</code> 的过程中，vector 会扩容高至 10 次。这样会对效率有巨大影响。在已经知道大致 size 的状况下，请先使用 <code>v.reserve(1000);</code>。这样能够极大提高效率。[2] 牢记：vector 和 string 的插入和删除总会使得迭代器失效。见第 1 条。 [3] 我们其实可以先 v.reserve() 一个超大的空间，然后在 push_back 或者 insert 一堆元素之后使用 17 条的 swap 缩容技法。这样能够避免频繁的堆分配和堆释放。</li>
<li>这一条非常棒！！也很有难度。揭示了不同的 4 种 string 实现的优劣势，同时也深化了传入指针进行构造和传入对象进行复制构造之间的共享能力的异同。联想到了 java 如果所有对象都需要接收一个参数构造的话，所有对象都传入同一个句柄构造，那么这些对象之间全都是“共享”的。也就是如果我在外部修改这个句柄，那么所有的这些对象都会“变化”。这是不安全的。这样我们需要调用 clone 方法来进行效率较低的复制才行。这样的“共享”能力是这些 string 之间的不同，也是 C++ 和 Java 之间的部分区别。详情请见书中条款 15 才好。阅读原著才是坠吼的。</li>
<li>在把 vector 和 string 的指针传递给一个 C API 类似于 <code>void haha(const int *begin, int size)</code> 这种的时候，需要谨慎再谨慎：[1] vector 尽量使用 <code>haha(&amp;*v.begin(), v.size())</code> 进行调用，而不是 <code>haha(v.begin(), v.size())</code>。因为前者符合语义是一个指针，而后者是一个 iterator。虽然在 vector 中确实是一样的。但是尽量写后者。[2] 如果有 <code>haha(const char *ptr)</code> 这种，需要使用 <code>haha(s.c_str())</code> 来进行调用。不过要注意：string 的最后可能没有 ‘\0’。因为 string 其实就是类似于 vector<char> 的定位，就是一个容器而已，只不过装的全是 char 字符。因此，在 <code>haha</code> 内部进行字符串遍历的时候，说不准中间会遇到 ‘\0’ 的情况。虽然 c_str() 会在返回的 const char * 后边自动加上一个 ‘\0’，但是并不保证字符串中间没有 ‘\0’。所以这里要注意一下。[3] 在 [1] 中，<code>haha</code> 有可能修改 vector 内部的值。要注意。如果我们传进来的 vector 是有序的，那么只能祈祷 <code>haha</code> 结束之后 vector 还是有序的了。[4] 在 C API 对 vector 初始化是没什么问题的。因为 vector 和 array 有着内存布局的兼容性。对 string 初始化可能要麻烦些，需要先初始化一个 vector<char>，然后再 copy 到 string 中去。 ==&gt;  扩展：可以用 C API 初始化 vector<double long=""> 啥的，再复制到 list/deque 也是可以的。但是，最好不要用 C API 初始化数组。因为我们未必知道它的大小，会比较危险。而且其实 13 条的本意是：尽量用 vector 来代替数组。</double></char></char></li>
<li>使用 swap 技巧来对无法缩容的 vector 进行缩容。<code>vector&lt;T&gt;(target_vec).swap(target_vec)</code> 即可做到。这里假设 <code>target_vec</code> 的 capacity 远远大于 size，有可能是一开始 reserve 时计算不正确引起，也有可能是本来我有 10001 个元素，在加到 10000 个的时候 vector 扩容 2 倍变成 20000，但是接下来只有最后一个元素被 push_back。于是有 9999 个空余的空间。这样，先复制构造 <code>target_vec</code>，就可以有 size == capacity 的新的匿名 vector。然后我们再把它跟有特别多空闲空间的 <code>target_vec</code> 进行交换即可。交换完之后匿名 vector 就会被自动析构。所以我们原先 capacity == 20000 的就消失掉了。留下的是 capacity == 10001 正好的。</li>
<li>避免使用 <code>vector&lt;bool&gt;</code>。<code>vector&lt;bool&gt;</code> 是针对 vector 特化的产物，<strong>不是标准的 STL 容器</strong>。而且，<code>vector&lt;bool&gt;</code> <strong>其实并不储存 bool</strong>。bool 一个才占用 1 byte，但是指针和引用要占用 8 bytes。指针 T<em> 和引用 T&amp; 竟然比 T 本身占得还多。而且存储 bool 本身也太消耗内存。于是 <code>vector&lt;bool&gt;</code> 被特化成了 bitset 一样的用 位域 来实现的方式。因而 `bool </em>pb = &amp;v[0]<code>是编译不过的。但是 v[0] 使用了 More Effective C++ 的代理类的方式，重载 vector&lt;bool&gt;::operator [] 返回一个嵌套 (nested) 代理类 (proxy class) 对象来模拟 vector&lt;T&gt;::operator []。但是这却是不完整的，比如我们没法做</code>bool *pb = &amp;v[0]`。不过我们可以使用 deque<bool> 或者 bitset 来进行代替就是了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v;</div><div class="line">	v.push_back(<span class="literal">true</span>);</div><div class="line">	v.push_back(<span class="literal">false</span>);</div><div class="line">	v.push_back(<span class="literal">true</span>);</div><div class="line">	</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; v[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">// 调试进去就知道，在 llvm 下，v[2] 返回一个代理类的对象 class __bit_reference &#123;&#125;。而且它的内部重载了 operator bool() 强转符号。</span></div><div class="line">	</div><div class="line">	<span class="keyword">bool</span> b = v[<span class="number">2</span>];				<span class="comment">// 可以通过。因为重载了 operator bool()</span></div><div class="line"><span class="comment">//	bool *bb = &amp;v[2];			// 但是指针无法通过！！因为 error: no viable conversion from '__bit_iterator&lt;std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;, false&gt;' to 'bool *'!!</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</bool></li>
</ol>
<hr>
<h1 id="第三章-关联容器"><a href="#第三章-关联容器" class="headerlink" title="第三章 关联容器"></a>第三章 关联容器</h1><hr>
<ol>
<li>理解相等 <code>(operator == )</code> 以及等价 <code>(operator &lt; or &gt;)</code> 之间的差异。<code>std::find()</code> 函数一般都以 <code>operator ==</code> 作为筹码，但是 <code>set&lt;T&gt;::find()</code> 和 <code>set&lt;T&gt;::insert()</code> 会以 <code>operator &lt;</code> 作为筹码(因为是红黑树)。所以，对一个关联容器 set，要优先调用 <code>set.find(xxx)</code> 而不是 <code>find(set.begin(), set.end(), xxx)</code>。因为在自己配置既定比较规则 <code>Comp</code> 的情况下，很有可能 <code>std::find</code> 会失败，而 <code>set.find()</code> 会找到想要的结果。这也是为什么要优先调用容器内方法的原因。[注] hash_set 和 hash_map 也有相等和等价的两种设计。虽然不是标准容器。</li>
<li><p>很好的比较器标准写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// operator() 两边全是一样的类型且已经确定的话，就可以使用 binary_function&lt;T1,T2,T3&gt; 这种了。</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringPtrLess</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">bool</span>&gt;&#123;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *ps1, <span class="keyword">const</span> <span class="built_in">string</span> *ps2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> *ps1 &lt; *ps2;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">set</span>&lt;<span class="built_in">string</span>*, StringPtrLess&gt; StringPtrSet;</div><div class="line">StringPtrSet s;</div><div class="line"></div><div class="line"><span class="comment">// 或者：</span></div><div class="line"></div><div class="line"><span class="comment">// 如果 operator() 两边的类型没有确定的话，在类上边加泛型做泛型类还太恶心，索性就不继承 binary_function了。</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringPtrLess</span> &#123;</span></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ptr1, <span class="keyword">typename</span> Ptr2&gt;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Ptr1 *pt1, <span class="keyword">const</span> Ptr2 *pt2)</span> </span>&#123;    <span class="comment">// 可以比较任意两个指针</span></div><div class="line">    <span class="keyword">return</span> *pt1 &lt; *pt2;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">set</span>&lt;<span class="built_in">string</span>*, StringPtrLess&gt; StringPtrSet;</div><div class="line">StringPtrSet s;</div></pre></td></tr></table></figure>
</li>
<li><p>对于关联容器，<strong>总是让比较函数在等值情况下返回 false</strong>。这一条非常重要！！因为比如说 <code>set&lt;int, less_equal&lt;int&gt;&gt; s</code> 这种，由于钦定比较器是 <code>return l &lt;= r;</code>，因此在 set 的 insert 10 的时候，如果原先已经有了一个 10，那么内部会做 <code>!(10 &lt;= 10) &amp;&amp; !(10 &lt;= 10)</code>，然后当然会返回 <code>false &amp;&amp; false</code>，于是说明 10 和 10 不是等价的。于是第二个 10 会被插入。所以这肯定是错的！根本不能指定 less_equal 作为比较器，这回破坏 set 容器！而对于 multiset，虽然插入不会有问题，但是取 equal_range 的时候，我们本来想要得到两个 10 的迭代器作为 equal_range，但是由于 10 和 10 不等价，我们最多能得到一个 10。因此这是不对的！根本不可以指定 less_equal 作为比较器，即，我们应该 <strong>总是让比较函数在等值情况下返回 false</strong>。</p>
</li>
<li><p>不要直接改变 set/mulitset 中的元素。你需要先 erase，再 insert。学完这个 clause，会对 cast 的强转方式的理解上升一个层次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span>&lt;T&gt;::iterator i = s.find(x);   <span class="comment">// 1. 找到元素迭代器</span></div><div class="line"><span class="keyword">if</span>(i != s.end()) &#123;</div><div class="line">  <span class="function">T <span class="title">temp</span><span class="params">(*i)</span></span>;   <span class="comment">// 2. 复制一份出来。</span></div><div class="line">  <span class="comment">// ...        // 3. do some change on temp</span></div><div class="line">  s.erase(i++); <span class="comment">// 4. remove i  // 递增迭代器保证 i 是有效的。因为下一步将要用到。</span></div><div class="line">  s.insert(i, temp); <span class="comment">// 5. use hint to insert the modified `temp`. O(1).</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>考虑使用 sorted vector 来代替 set、map，如果容器的插删以及查找是<strong>分为两个部分集中进行</strong>的话，那么请使用 sorted vector 代替 set、map。而且缓存命中率会明显 up。<br>不过……if (i != vw.end() &amp;&amp; *i == w) ??? 这里不太明白…???????说是见 19 条??? 然而我并没有看懂 QAQ</p>
</li>
<li>当效率至关重要的时候，请在 map::operator[] 与 map::insert 之间谨慎做出选择。<strong>这一条也很有难度</strong>。因为在<code>m[1] = obj;</code><strong>作为添加操作</strong>的时候，其实相当于调用了 <code>pair&lt;map..::iterator, bool&gt; it =  m.insert(make_pair(1, Obj())); it.first-&gt;second = obj;</code> 相当于在 insert 的基础上，又多构造了一个临时的 Obj()，最后还 copy 了一个对象进去。多调用了 3 次没必要的函数，即 Obj() 的 constructor，Obj 的 destructor，以及 Obj 的 operator = 的 copy assignment。在需要效率的时候这个是比较浪费的。但是，在<code>m[1] = obj</code><strong>作为更新操作</strong>的时候，情况正好相反了过来。因为 insert 的时候需要构造临时 pair 才行，pair 之中还要构造临时 obj 才行。这样将会引发比较大的开销 —— 因为是原先已经有过，只更新 value 即可，没有必要连同 key 一起包装成一个 pair。而 operator[] 不需要使用 pair，因此 operator [] 的效率更高。而且语法更优雅。但是后边的代码又涉及到了 23 条没看懂 QAQ 的问题……为何要额外判断一次 <em>i == w 呢???? 见 45 条。因为 lower_bound 如果查找成功就返回查找到的第一个符合要求的元素；但是如果没有成功的话，那么就返回第一个可以插入的位置。因此需要使用 </em>i == w 这个 “相等性判断” 来判断是否查找成功了。注意：虽然 lower_bound 使用了 “等价性” 来作为判断原则，但是最后需要用 “相等性” 来判断是否查找成功。因而，如果 lower_bound 指定的比较器和判断原则不同步，就会出现问题。所以这里需要谨慎下。或者可以使用 equal_range 进行判断则更加轻松，但是比 lower_bound 要更加昂贵。</li>
<li>散列容器。并不是 STL 标准。但是各种 STL 中均有提供。此条款仅仅是介绍，略。</li>
</ol>
<hr>
<h1 id="第四章-迭代器"><a href="#第四章-迭代器" class="headerlink" title="第四章 迭代器"></a>第四章 迭代器</h1><hr>
<ol>
<li>使用 iterator 代替 const_iterator。最好全用 iterator。当然，iterator 可以隐式转换为 const_iterator。</li>
<li>使用 distance() 和 advance() 将容器的 const_iterator 转换成 iterator。</li>
<li><p>使用 reverse_iterator 删除的话，需要转为 iterator 才行。但是注意它们的关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;   <span class="comment">// 想要删除 3：</span></div><div class="line">v.erase((++find(v.rbegin(), v.rend(), <span class="number">3</span>)).base());  <span class="comment">// 要将返回的 reverse_iterator 先 ++ 再取 base，iterator 就会指向 3 了。否则，iterator 会变成 4。</span></div><div class="line"></div><div class="line"><span class="comment">// 但是，下边的情况是编译不过的！</span></div><div class="line"><span class="comment">// v.erase(-- find(v.rbegin(), v.rend(), 3).base() );  </span></div><div class="line"><span class="comment">// 这样对 vector、string 是不行的。对于其他如 list、map、set 等都是可以的。因为 vector 的 reverse_iterator 取 base 之后返回 iterator，是 T* 的指针类型。而 C 和 C++ 规范规定【函数返回的指针不可以修改】，因此必然会编译错误。所以，只能在 find 结束时候的 reverse_iterator 取 base 之前就预先判断并调整调用 base 之后产生 iterator 的位置才行。</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果我们想要性能的提升，而且不需要格式化(比如对于文件中的空格和 tab 也全部读取的话)，我们可以使用 istreambuf_iterator。直接从缓冲区读取是非常快的。而 istream_iterator 是通过 operator &gt;&gt; 从输入流中读取的。</p>
</li>
</ol>
<hr>
<h1 id="第五章-算法"><a href="#第五章-算法" class="headerlink" title="第五章 算法"></a>第五章 算法</h1><hr>
<ol>
<li>确保目标区间足够大。[1] 一定要小心插入到容器的最后。不要用 <code>transform(v.begin(), v.end(), result.end(), func)</code>，而是要用 <code>transform(v.begin(), v.end(), back_inserter(result), func)</code>！！没 malloc 空间且没有 constructor 初始化就复制上去是 UB！ [2] 但是，如果我们要倒着在 result 中插入 v 的话(即 <code>reverse</code>)，就不好弄了。因为 vector 并没有 <code>push_front()</code>，因此没有 <code>front_inserter</code>。因而只能使用另一个技巧：不能倒着插进 result，何不倒着遍历 v 呢？于是可以：<code>transform(v.rbegin(), v.rend(), back_inserter(result), func)</code>。 [3] 如果是在 result 的中间插入整个区间 v 的话，可以使用 inserter。比如在中间插入：<code>transform(v.begin(), v.end(), inserter(result, result.begin()+result.size()/2), func)</code>。但是这样效率对于 vector、string、deque 这样的连续容器肯定是 O(n) + O(重新 allocate 内存)。虽然不能避免 O(n)，但是内存分配还是可以避免。我们可以使用 <code>result.reserve(v.size() + result.size())</code> 预分配内存。 [4] 如果在 [3] reserve 之后再执行 [1] 这种情况，也是不可以的！Effective STL 中说的不明晰。我来补充一下：如果 v 中的元素所在的类中有 const 成员的话，这样的 copy 是会失败的！因为常成员是不允许 copy 的！！只能通过 malloc + copy constructor 进行构造！如今 malloc 有了，但是没有 copy constructor，直接使用 operator = 进行强制复制，也会在成员有 const 的时候编译失败！！/ 而且即便没有失败，也是错的。因为并没有通过 result 的接口来进行 push_back，因此 result 的 size 和 iterator end 并没有发生改变。只是拷贝了内存过去。因而也一定是 UB 行为。 [5] 如果想要直接覆盖掉 result 的话，那么可以写 <code>transform(v.begin(), v.end(), result.begin(), func)</code> 注意 $3 参数不是 <code>front_inserter(result)</code>！！那是插入。而且在 vector 也会编译错误，由于 vector 没有 push_front。这样的话，v 会直接覆盖 result 的空间。但是！这样也是错的。因为没保证 result 的 size 大小大于 v 的 size 大小(注意是 size，不是 capacity)，很可能导致 UB。所以之前要写：<code>if(result.size() &lt; v.size()) { result.resize(v.size()); }</code> 才行。(注意是 resize 不是 reserve！resize 是会 malloc + construct 的，面向容器的 size 属性；而 reserve 是只会 malloc 但是不会 construct 的，面向容器的 capacity 属性。) [6] 或者 <code>result.clear(); result.reserve(v.size()); transform(v.begin(), v.end(), back_inserter(result), func);</code> 也好！！</li>
<li>了解各种与排序有关的选择。a. 把排名在前 20 个 数组元素取出：[1] paritial_sort 基于堆排序。有序。<code>partial_sort(v.begin(), v.begin()+20, v.end(), Compare)</code> [2] nth_element 能把高于 20 和低于 20 的 element 分开，但是除了第 20 位，其他顺序都不确定。<code>nth_element(v.begin(), v.begin()+19, v.end(), Compare)</code>。注：nth_element 还可以寻找区间的中间值/找到特定百分比的值  b. 按照一等品和二等品的类别进行筛选：[1] paritition：<code>vector&lt;T&gt;::iterator goodEnd = partition(v.begin(), v.end(), hasAcceptableQuality);</code>。[2] 如果对于相同质量级别的 T，要保持他们的相对顺序关系(稳定排序)，可以使用 stable_sort。  [注] partition / stable_sort 只需要 bidirectory_iterator 就可以工作。所以所有标准容器都可以使用 partition / stable sort。若要强行对 list 使用需要 RandomAccessIterator 才能用的 nth_element / partial sort 的话，可以把 list copy 到 vector 中去。而且 list 内置有 sort 函数。</li>
<li>和 clause 9 一样！是 erase-remove 以及 list.remove()，额外的还有 erase-unique! 以及 list.unique()。</li>
<li><strong>重要</strong>！！千万不要贸然在 vector<t*> 的容器上使用 remove！！因为 remove 做完之后，极有可能很多指针句柄就被覆盖，从而使堆内存不会被释放！！<strong>非常非常重要</strong>！！！所以，只要遇到可能要释放或者 remove 的话，<strong>就用 vector<shared_ptr<t>&gt; 就好了</shared_ptr<t></strong>！！这样才能够完美！！否则极有可能出现内存泄漏！！</t*></li>
<li><p>了解哪些算法要求使用排序的区间作为参数：<code>binary_search、lower_bound、upper_bound、equal_range、set_union、set_intersection、set_difference、set_symmetric_difference、merge、inplace_merge、includes</code>。还有虽然不一定要求 sorted，但是经常和 sorted 一起使用：<code>unique、unique_copy</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</div><div class="line"><span class="comment">// bool result = binary_search(v.begin(), v.end(), 5);  // 错误！result 是 false！因为比较器有问题！默认是 less&lt;int&gt;()，所以根本找不到！</span></div><div class="line"><span class="keyword">bool</span> result = binary_search(v.begin(), v.end(), <span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 正确～</span></div></pre></td></tr></table></figure>
</li>
<li><p>通过 mismatch 或者 lexicographical_compare 实现简单的忽略大小写的字符串比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只是代码记录：</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ciCharLess</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c1)) &lt; <span class="built_in">tolower</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(c2)); <span class="comment">// 为什么要强转为 unsigned char ??? 好像因为 tolower 只接受 unsigned char???</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ciStringCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> lexicographical_compare(s1.begin(), s1.end(), s2.begin(), s2.end(), ciCharLess);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 取巧：</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ciStringCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> stricmp(s1.c_str(), s2.c_str());   <span class="comment">// 非标准库函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>C++11 中已经有了 copy_if 了。一开始不完美的 copy_if 使用 remove_copy_if 和 not1 配接器实现的。但是实现的 copy_if 的最后一个断言参数必须接受 ptr_fun(func) 这样丑恶的配接器。因此还是要手动一个一个遍历实现才行啊。</p>
</li>
<li>accumulate 这个函数在函数式编程中是相当强大的。这里也是一样。不过很值的在意的是，Mayers 在最后提到的，accumulate 不允许副作用，比如修改外部的全局变量等等；像书上的栗子中，把 $4 的 operator () 的函数对象所在的类中设置成员变量并且修改也算是“副作用”。而 for_each 允许。这是为什么呢？</li>
</ol>
<hr>
<h1 id="第六章-函数子、函数子类及其他"><a href="#第六章-函数子、函数子类及其他" class="headerlink" title="第六章 函数子、函数子类及其他"></a>第六章 函数子、函数子类及其他</h1><hr>
<ol>
<li><p>使用 Bridge Pattern 来创建一个桥接类，来给算法传递小型的比较器来代替巨大且多态的函数对象。(非常有用！) 因为 algorithm 所接收的 Comp 统统都是按值传递的！虽然可以强行改变为引用，但是极其有可能会发生别的地方的编译错误。比如 <code>for_each&lt;int, DoSomething &amp;&gt;(v.begin(), v.end(), dosth);</code>。所以要尽量使用桥接的方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPFC</span> :</span> <span class="keyword">public</span> unary_function&lt;T, <span class="keyword">void</span>&gt; &#123; <span class="comment">// BPFC: Big Polymorphic Functor class</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Widget w;   <span class="comment">// 大量的数据</span></div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  ...</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> T &amp; val)</span> <span class="keyword">const</span></span>; <span class="comment">// 还是多态的。传值的话容易引发剥离问题。</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 可以把 BPFC 类修改为 BPFCImpl，而把桥接类命名为 BPFC：</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPFCImpl</span> :</span> <span class="keyword">public</span> unary_function&lt;T, <span class="keyword">void</span>&gt; &#123; <span class="comment">// 和上边一样，除了多了个虚析构函数和一个友元。</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Widget w;</div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  ...</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> T &amp; val)</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="keyword">virtual</span> ~BPFCImpl();    <span class="comment">// 由于是多态的，必须用虚析构函数！！</span></div><div class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BPFC</span>&lt;T&gt;;</span>     <span class="comment">// 多了个友元！让 BPFC 能够访问！</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BPFC</span> :</span> <span class="keyword">public</span> unary_function&lt;T, <span class="keyword">void</span>&gt; &#123; <span class="comment">// 也要继承 unary_function。因为同样实现了 operator ()，虽然只不过是转调用 BPFCImpl 的 operator ()，但是也要实现 unary_function.</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  BPFCImpl&lt;T&gt;* pImpl;   <span class="comment">// 其实书中建议改成 shared_ptr&lt;BPFCImpl&lt;T&gt;&gt; pImpl;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T &amp; val)</span> <span class="keyword">const</span> </span>&#123; pImpl -&gt; <span class="keyword">operator</span>()(val); &#125;   <span class="comment">// 转调用！</span></div><div class="line">      <span class="comment">// 这样，就把原先一个超多数据且是多态的大对象变成了一个单态的小对象！</span></div><div class="line">      <span class="comment">// 唯一需要注意的是，需要谨慎处理 BPFC 的复制动作 (没看懂) ????? 书中的建议是最好成员变量使用引用计数 shared_ptr。为啥 ?????</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>要保证一个 functor 是纯函数(这一章节很棒，描述了 remove_if 中由于要把 带有计数器副作用，想要删除第三个元素的 functor 传递给 find 和 remove_copy_if 两次而导致产生 UB 现象：传递给 find 的时候计数器为 0，find 结束之后计数器为 3；但是到 remove_copy_if 的时候语义应为计数器为 3，但是由于是复制 remove_if 的 functor，造成计数器还是 0，因而第 3、6 位置的两个元素全被删除。)。一个限制方法就是：在 operator()(…) 后边加上 const 限制一下！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> ... &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(...)</span> <span class="keyword">const</span></span>;  <span class="comment">// 注意这个 const ！！确实应该写这个。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>如果一个 class 是一个 functor (重载了 operator())，那么应该让它可配接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ptr_fun 可以对 函数指针使用。让它暂时升级成为一个函数对象(class)。</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInteresting</span><span class="params">(<span class="keyword">int</span> v)</span></span>;    <span class="comment">// 一个 predicate 函数</span></div><div class="line"><span class="keyword">auto</span> it = find_if(v.begin(), v.end(), isInteresting);   <span class="comment">// 找到符合的第一个 elem</span></div><div class="line"><span class="keyword">auto</span> itt = find_if(v.begin(), v.end(), not1(ptr_fun(isInteresting))); <span class="comment">// 如果要找到不符合的第一个，我们需要套上 not1 和 ptr_fun。仅仅套上一层 not1 是不够的。这是因为 not1 需要 unary_function::argument_type 的 type 泛型定义，但是一个函数指针是不可能有的。所以用继承 unary_function 的 ptr_fun 把 isInteresting 函数指针包上一层，让它具有 unary_function::argument_type 而已。</span></div><div class="line"></div><div class="line"><span class="comment">// 注意：在自己编写可以继承自 unary_function 和 binary_function 的 函数对象(class) 的时候：</span></div><div class="line"><span class="comment">// 一般而言，传递给 unary_function 和 binary_function 的非指针类型都需要去掉 const 和 &amp; 部分(没试验过) 作为模板参数。但是如果有指针的话，可以用 const T* 作为模板参数。</span></div><div class="line"></div><div class="line"><span class="comment">// 对 非指针的类型：</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WidgetCompare</span> :</span> <span class="keyword">public</span> binary_function&lt;Widget, Widget, <span class="keyword">bool</span>&gt; &#123; <span class="comment">// 注意只写了 Widget 作为模板参数！</span></div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Widget &amp; lhs, <span class="keyword">const</span> Widget &amp; rhs)</span> <span class="keyword">const</span></span>;  <span class="comment">// 注意这里的类型却又变成了 const Widget &amp; 了！！</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 对 指针的类型：</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WidgetCompare</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> Widget *, <span class="keyword">const</span> Widget *, <span class="keyword">bool</span>&gt; &#123; <span class="comment">// 这里用了完全体的 const Widget *...... 然而并不知道为什么。</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Widget *lhs, <span class="keyword">const</span> Widget *rhs)</span> <span class="keyword">const</span></span>;  <span class="comment">// 这里和模板参数的声明一模一样！！  WHY ?????</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>理解 ptr_fun、mem_fun、mem_fun_ref 的来由。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">几个要注意的地方：(以下全用 for_each 举例)</div><div class="line">1. 对于普通的函数指针而言，使用 ptr_fun 进行封装的地点仅仅在于函数指针前边有没有包裹配接器 not1、not2、bind1st、bind2nd。有的话因为要调用 unary_function::argument_type，就必须要使用 ptr_fun。也可以见上一个条款。</div><div class="line">2. 对于容器中存放指针，且 for_each 要接收一个成员函数指针而言，无论有没有配接器 not1 等，由于他们需要使用 obj-&gt;(*ptr)() 的形式调用，因此必须使用 mem_fun 来进行配接。</div><div class="line">3. 对于容器中存放对象，且 for_each 要接收一个成员函数指针而言，无论有没有配接器 not1 等，由于他们需要使用 obj.(*ptr)() 的形式调用，因此必须使用 mem_fun_ref 来进行配接。</div><div class="line">4. 重要：指针容器支持多态，而对象容器由于剥离现象，不会支持多态。而指针容器可以使用 vector&lt;shared_ptr&lt;T&gt;&gt; 来进行封装。</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
<li><p>确保 less<t> 和 operator &lt; 具有相同的语义。也就是，如果要自定义比较器，最好选择自己定义一个类，而不是特化 std::less<t> 的标准模板库。仅此而已：保证 less<t> 的完整性，不要乱修改它，需要的时候自己定义一个新的 class，让 std::less<t> 的实现是默认的即可。</t></t></t></t></p>
</li>
</ol>
<hr>
<h1 id="第七章-在程序中使用-STL"><a href="#第七章-在程序中使用-STL" class="headerlink" title="第七章 在程序中使用 STL"></a>第七章 在程序中使用 STL</h1><hr>
<ol>
<li><p>算法调用优先于手写循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 很好的栗子：想要对数组中的每个元素都加上 41，然后把整体插入到一个 vector 的前边：</span></div><div class="line">transform(arr, arr + n, inserter(v, v.begin()), bind2nd(plus&lt;<span class="keyword">double</span>&gt;(), <span class="number">41</span>));</div><div class="line"><span class="comment">// 注意几点：inserter 虽然指定 v.begin() 是插入位置，但是 inserter 内部会随着插入，会把内部的 iter + 1。也就是，最终插入的结果并不是和原来的顺序相反的。但是，如果不使用内置算法，而是手动写循环的话，有可能写成这样：insert(d.begin(), arr[i])，这样就是彻头彻尾地每次都插在 begin 处，因为 insert 函数不会对迭代器进行自增。因而，最终插入的结果是和原来的顺序正好相反，不是我们想要的结果了。</span></div><div class="line"><span class="comment">// 记住：inserter 内部会随着每插入一个元素，会把内部的 iter ++。</span></div></pre></td></tr></table></figure>
</li>
<li><p>容器的成员函数优先于同名的算法。[1] 无论是效率还是正确性(见 19 条。<code>std::find</code> 的条件是相等，即 <code>operator ==</code>；而 <code>set&lt;T&gt;::find</code> 的条件是等价性，即 <code>operator &lt; / &gt;</code> )。[2] 且，map 本质使用 pair 储存，如果用 <code>std::count</code>，你肯定需要自定义比较器。而 map 内部的 <code>map&lt;K,V&gt;::count</code> 则是只比较 key 不比较 value。如何使用它们，需要我们的权衡。[3] 在 list 中，同名的 <code>remove、remove_if、unique、sort、merge、reverse</code> 全都在效率上大大提高，因为它们被设定成了仅仅改变 list 的指针而不用重新 allocate 并复制对象。但是 std 算法的处理则是需要大量复制来实现这些算法。因此 list 的成员算法性能肯定更高。且，list 的 <code>remove、remove_if、unique</code> 的语义也不同 —— 不必使用 <code>erase-remove/remove_if/unique</code> 的手段进行删除，而是设定成了直接删除。而 <code>std::sort</code>(需要 RandomAccessIterator) 和 <code>std::merge</code> 根本就不能用在 list 上。</p>
</li>
<li><p>正确区分 <code>count</code>、<code>find</code>、<code>binary_search</code>、<code>lower_bound</code>、<code>upper_bound</code> 以及 <code>equal_range</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// count 某种程度可以代替 find：只不过它会遍历全部区间，但是 find 找到就会返回。</span></div><div class="line"><span class="keyword">if</span> (count(v.begin(), v.end(), x)) &#123;...&#125; <span class="comment">// count 返回 int。不等于0 的话就是找到了。</span></div><div class="line"><span class="keyword">if</span> (find(v.begin(), v.end(), x) != v.end()) &#123;...&#125;   <span class="comment">// 和上边一样。只不过 find 效率高些。因为不用遍历全部区间。</span></div><div class="line"></div><div class="line"><span class="comment">// 在 list 中插入的时候，保持所有元素的顺序：</span></div><div class="line">l.insert(upper_bound(l.begin(), l.end(), newX, Comp()), newX); <span class="comment">// 插入到原先有的 newX 之后，如果没有，就找 upper_bound 返回的合适的位置进行插入。</span></div><div class="line"></div><div class="line"><span class="comment">// vector 中删除比某个值小的所有元素：</span></div><div class="line">v.erase(v.begin(), lower_bound(v.begin(), v.end(), Predicate()));</div><div class="line"><span class="comment">// vector 中删除这个值以及比这个值小的所有元素：</span></div><div class="line">v.erase(v.begin(), upper_bound(v.begin(), v.end(), Predicate()));</div><div class="line"></div><div class="line"><span class="comment">// vector 中 equal_range 代替 find 和 count：</span></div><div class="line"><span class="keyword">auto</span> &amp; iter_pair = equal_range(v.begin(), v.end(), x);  </div><div class="line"><span class="keyword">if</span> (iter_pair.first != iter_pair.second) &#123;  <span class="comment">// 代替 find</span></div><div class="line">  ... <span class="comment">// 存在 x 这样的值</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  ... <span class="comment">// 不存在 x 这样的值。因为返回的两个区间迭代器指向同一个地方</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> count = distance(iter_pair.first, iter_pair.second);  <span class="comment">// 代替 count。</span></div><div class="line"></div><div class="line"><span class="comment">// 对于关联容器：set、map 等，不必使用 std::count、std::find、std::equal_range，直接使用 m.count、m.find、m.equal_range 即可！</span></div></pre></td></tr></table></figure>
<p>搬运：<br><img src="https://wind2412.files.wordpress.com/2017/09/14e993cabe8749c98832f576b9f73c00.jpg?w=816&amp;h=612&amp;zoom=2" alt="IMG_0895.JPG"></p>
</li>
<li><p>考虑使用函数对象而不是函数作为 STL 算法的参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 1. 函数指针会拒绝 inline 优化。如果传入函数指针，有可能本来 inline 的函数就无效了。</span></div><div class="line"> <span class="comment">//    比如 sort() 要快于 qsort()。</span></div><div class="line"> </div><div class="line"> <span class="comment">// 2. 有些情况可能会产生编译不通过的问题......</span></div><div class="line"> <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s&#123;<span class="string">"haha"</span>, <span class="string">"hehe"</span>&#125;;</div><div class="line"> transform(s.begin(), s.end(), ostream_iterator&lt;<span class="built_in">string</span>::size_type&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>), mem_fun_ref(&amp;<span class="built_in">string</span>::size));	<span class="comment">// g++ 编译通过但是 clang++ 编译不通过。</span></div><div class="line">  </div><div class="line"> <span class="comment">// 3. Mayers 给定另一个例子我使用 LLVM 和 GCC 都测试过，完全没有问题啊......还是把代码列上来把：</span></div><div class="line"> </div><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">average</span><span class="params">(T val1, T val2)</span> </span>&#123;		<span class="comment">// 例子 2</span></div><div class="line">	<span class="keyword">return</span> (val1 + val2)/<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIter1, <span class="keyword">typename</span> InputIter2&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeAverage</span><span class="params">(InputIter1 begin1, InputIter1 end1, InputIter2 begin2)</span> </span>&#123;</div><div class="line">	transform(begin1, end1, begin2, ostream_iterator&lt;<span class="keyword">typename</span> iterator_traits&lt;InputIter1&gt;::value_type&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>), average&lt;<span class="keyword">typename</span> iterator_traits&lt;InputIter1&gt;::value_type&gt;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</div><div class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s2&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</div><div class="line">transform(s1.begin(), s1.end(), s2.begin(), ostream_iterator&lt;<span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">decltype</span>(s1.begin())&gt;::value_type&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>), average&lt;<span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">decltype</span>(s1.begin())&gt;::value_type&gt;);		<span class="comment">// 这第二个例子函数指针倒是没有问题的啊。</span></div><div class="line">writeAverage(s1.begin(), s1.end(), s2.begin());</div></pre></td></tr></table></figure>
</li>
<li><p>避免产生 “直写型” (write-only) 的代码。“直写型” 就是指通过灵感直接产生的代码（逃，写出来一大长串顺风顺水，但是阅读起来或者回忆起来根本看不懂。23333</p>
</li>
<li>略。并不是特别重要。</li>
<li>略。</li>
<li>略。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/25/如果不想让你的mac在访问next主题的博客的时候烫烫烫/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wind2412">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blue_sky.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wind2412的部落格✨～">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/25/如果不想让你的mac在访问next主题的博客的时候烫烫烫/" itemprop="url">
                  如果不想让你的mac在访问next主题的博客的时候烫烫烫
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-25T23:40:15+08:00">
                2017-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>请关掉 <code>canvas_next</code> 效果！！！<br><img src="https://wind2412.files.wordpress.com/2017/09/draggedimage.png" alt="IMAGE"><br>否则你的 mac 的耗热量会飙升！活动监视器内<code>对能耗的影响</code>会飙到 200+ ！！正常也就 0.几…… 我还以为我博客出问题了呢（<br>珍爱 mac，请远离这些酷炫的效果QAQ</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/09/读者写者优先问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wind2412">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blue_sky.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wind2412的部落格✨～">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/09/读者写者优先问题/" itemprop="url">
                  读者写者优先问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-09T11:30:20+08:00">
                2017-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://tadvent.wordpress.com/2008/12/20/读者-写者问题-写者优先与公平竞争/" target="_blank" rel="external">参阅博客: 輝夜の永遠亭</a></p>
<h1 id="读者优先："><a href="#读者优先：" class="headerlink" title="读者优先："></a>读者优先：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">semaphore read_cnt_mutex = 1;   //对临界区int readcount进行互斥</div><div class="line">semaphore fmutex = 1;           //对读者--写者，写者--写者进行互斥。（双重作用）</div><div class="line">int read_cnt = 0;</div></pre></td></tr></table></figure>
<p><strong>READER:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">P(read_cnt_mutex);              //获取对read_cnt的互斥锁</div><div class="line">if(read_cnt == 0)	P(fmutex);  //注意这条语句必须放在P(read_cnt_mutex)中，因为if语句和P语句之间不是原子的！！必须要防止其他的读者进程对read_cnt进行修改！！</div><div class="line">read_cnt ++;</div><div class="line">V(read_cnt_mutex);</div><div class="line"></div><div class="line">read();</div><div class="line"></div><div class="line">P(read_cnt_mutex);</div><div class="line">read_cnt --;</div><div class="line">if(read_cnt == 0)	V(fmutex);  //同上。因为if和V之间不是原子的，必须防止其他读者进行修改。  且，注意每次到0的时候释放fmutex，让写者可以进入。</div><div class="line">V(read_cnt_mutex);</div></pre></td></tr></table></figure>
<p><strong>WRITER:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">P(fmutex);    //只要拿到fmutex互斥锁，就可以进行“写”操作了。</div><div class="line"></div><div class="line">write();</div><div class="line"></div><div class="line">V(fmutex);</div></pre></td></tr></table></figure>
<p>从上边我们可以看出：如果在writer正在等待fmutex的时候，这时一定是已经有多个读者在读取。倘若读者不断地到来，那么writer必然一直处于饥饿的状态。</p>
<p>因此，这种情况下，我们必须想一个措施，让写者的优先级提高。也就是，让写者在“到来”的时候，就要让不断到来的读者停止，让正在读的读者们全部读完之后，写者就开始写。</p>
<p>换句话说，就是要“当写者到的时候，屏蔽源源不断新来的读者，等待已有的读者读完，然后自己进去写”。</p>
<p>因此，<a href="https://tadvent.wordpress.com/2008/12/20/读者-写者问题-写者优先与公平竞争/" target="_blank" rel="external">輝夜の永遠亭</a>提供了一个思路，就是使用一个queue变量，来限制源源不断的后来读者。</p>
<p>在计算机网络中，我们都知道各种“层”。大体思想无非是，如果有问题解决不了，就加一层；如果还解决不了，就加两层。</p>
<p>这里用了同样的思想。不过用“门”来比喻更好。就是写者在fmutex这个互斥的“门”外边又套了一层门进行把关，一旦写者到来，他就把外边这层门(semaphore queue)封死，因此源源不断的后来读者就全部封死在外边了。接下来就是写者在门里等着，等屋子(fmutex)里的已有的所有读者都读完，然后自己进去写。</p>
<p>思想很简单吧！我们来实现一下。</p>
<h1 id="公平竞争"><a href="#公平竞争" class="headerlink" title="公平竞争"></a>公平竞争</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">semaphore read_cnt_mutex = 1;</div><div class="line">semaphore fmutex = 1;</div><div class="line">semaphore queue = 1;</div><div class="line">int read_cnt = 0;</div></pre></td></tr></table></figure>
<p><strong>READER:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">P(queue);      //套上了一个“门”，READER必须得经过这个”门“，才能进”屋”读取。</div><div class="line">P(read_cnt_mutex);</div><div class="line">if(read_cnt == 0)	P(fmutex);</div><div class="line">read_cnt ++;</div><div class="line">V(read_cnt_mutex);</div><div class="line">V(queue);      //过门了，就释放～</div><div class="line"></div><div class="line">read();</div><div class="line"></div><div class="line">P(read_cnt_mutex);</div><div class="line">read_cnt --;</div><div class="line">if(read_cnt == 0)	V(fmutex);</div><div class="line">V(read_cnt_mutex);</div></pre></td></tr></table></figure>
<p><strong>WRITER:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">P(queue);      //套上了一个“门”。</div><div class="line">P(fmutex);</div><div class="line">V(queue);      //注意放到这里才是符合语义的！	进门之后如果进了屋，就把门开放了。如果没进屋，就在门前守着，不让其他人进来。</div><div class="line"></div><div class="line">write();</div><div class="line"></div><div class="line">V(fmutex);</div></pre></td></tr></table></figure>
<p>哈哈哈。其实我想写成“写者优先”的。结果写完了之后发现时公平竞争TAT。遂把标题从“写者优先”变成了“公平竞争”。</p>
<p>这里我们看到，<strong>每个</strong>读者和写者都要过门，没过门就不能进。这显然是非常公平的呀！一次只有一个可以进门，这不是公平的是什么？</p>
<p>想要对写者偏心的话，就要改成：只对第一个写者需要过门，然后只要有这第一个写者在这里把关，那么后来源源不断的写者也可以涌入。只不过给后边的写者开小灶，直接免费过门，不需要等了。</p>
<p>回想第一个读者优先也是这样，只要第一个读者进了<strong>屋</strong>，那么接下来到来的读者不用参与竞争就可以免费进<strong>屋</strong>了。这里的写者也一样，只要第一个写者进了<strong>门</strong>，那么接下来到来的写者就可以不用竞争也可以免费过<strong>门</strong>了。</p>
<p>看下实现：</p>
<h1 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">semaphore read_cnt_mutex = 1;</div><div class="line">semaphore write_cnt_mutex = 1;</div><div class="line">semaphore fmutex = 1;</div><div class="line">semaphore queue = 1;</div><div class="line">int read_cnt = 0;</div><div class="line">int write_cnt = 0;</div></pre></td></tr></table></figure>
<p><strong>READER:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">P(queue);</div><div class="line">P(read_cnt_mutex);</div><div class="line">if(read_cnt == 0)	P(fmutex);</div><div class="line">read_cnt ++;</div><div class="line">V(read_cnt_mutex);</div><div class="line">V(queue);</div><div class="line"></div><div class="line">read();</div><div class="line"></div><div class="line">P(read_cnt_mutex);</div><div class="line">read_cnt --;</div><div class="line">if(read_cnt == 0)	V(fmutex);</div><div class="line">V(read_cnt_mutex);</div></pre></td></tr></table></figure>
<p><strong>WRITER:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">P(write_cnt_mutex);</div><div class="line">if(write_cnt == 0)	P(queue);     //你懂的。因为if不是原子，因此前边必须有互斥量～ 这个互斥量还对write_cnt进行了写互斥～ 双重作用。</div><div class="line">write_cnt ++;</div><div class="line">P(fmutex);      //等着屋里的原有读者读完</div><div class="line">V(write_cnt_mutex);</div><div class="line"></div><div class="line">write();</div><div class="line"></div><div class="line">P(write_cnt_mutex);</div><div class="line">write_cnt --;</div><div class="line">if(write_cnt == 0)	V(queue);</div><div class="line">V(fmutex);      //释放锁，如果write_cnt!=0还有写者，因为queue没释放，因此源源不断的读者过不了门，因而fmutex肯定花落别的writer家。如果是0，那么之前一句queue就被释放了。这样的话，就是读者和写者竞争咯，这里会公平地争夺过门的机会。但是如果writer抢到了门，那么之后的过程就对reader不公平了。</div><div class="line">V(write_cnt_mutex);</div></pre></td></tr></table></figure>
<p>就完成啦～～</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/blue_sky.jpg"
               alt="wind2412" />
          <p class="site-author-name" itemprop="name">wind2412</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wind2412" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接o(*////▽////*)q
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.google.com/" title="Google~" target="_blank">Google~</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wind2412</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  
    

    
  





  






  





  

  

  

  

  

</body>
</html>
